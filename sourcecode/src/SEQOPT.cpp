#include <ilcplex/ilocplex.h>   /* cplex */      
#include <vector>              
#include <omp.h>               /* parallel */
#include "Selfmath.h"

namespace patch {template < typename T > std::string to_string( const T& n ){std::ostringstream stm; stm << n; return stm.str() ;}}

using namespace std;
////////////////////////////////////////////////////////
//                                                    //
// Source CPP Code for the Sequential Optimization Method 
// Vessel Service Planning in Seaports, Operations Research
//                                                  
// Authors: Lingxiao Wu, Yossiri Adulyasak, Jean-François Cordeau, Shuaian Wang 
///////////////////////////////////////////////////////

//input data starts here

extern const int S = 6;
extern const int K =10;
extern const int T = 288;
extern const int B = 10;
extern const int I = 20;
extern const int NCPN = 0;
extern const int HWPN = 180;
int BRT[B]={0,14,0,21,6,47,20,0,22,44};
int Chaocu[B]={-1,-1,-1,-1,-1,-1,-1,-1,-1,51};
int HDT[B]={-1,15,-1,22,7,48,21,-1,23,45};
int E[I][2]={{0,39},{0,28},{23,71},{29,77},{38,86},{62,110},{87,135},{93,141},{101,149},{140,188},{59,107},{71,119},{83,131},{145,193},{150,198},{133,181},{160,208},{161,209},{174,222},{216,264}};
int BRK[S][2]={{14,34},{62,82},{110,130},{158,178},{206,226},{254,274}};
int VLL[K]={0,0,0,2,1,1,0,0,0,0};
int F[I][I]={{0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0}};
int D[I+1]={7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,6};
int H[K][B]={{52,52,52,52,52,52,52,52,52,52},{64,64,64,64,64,64,64,64,64,64},{53,53,53,53,53,53,53,53,53,53},{109,109,109,109,109,109,109,109,109,109},{105,105,105,105,105,105,105,105,105,105},{64,64,64,64,64,64,64,64,64,64},{66,66,66,66,66,66,66,66,66,66},{61,61,61,61,61,61,61,61,61,61},{66,66,66,66,66,66,66,66,66,66},{69,69,69,69,69,69,69,69,69,69}};
int Q[I+1][I+1]={{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};
int ST[S][2]={{0,47},{48,95},{96,143},{144,191},{192,239},{240,287}};
int C1[K]={50000,50000,50000,50000,50000,50000,50000,50000,50000,50000};
int C2[I][T]={{0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,524,526,528,530,532,534,536,538,540,542,544,546,548,550,552,554,556,558,560,562,564,566,568,570,572,574},{0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,524,526,528,530,532,534,536,538,540,542,544,546,548,550,552,554,556,558,560,562,564,566,568,570,572,574},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,524,526,528},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138,144,150,156,162,168,174,180,186,192,198,204,210,216,222,228,234,240,246,252,258,264,270,276,282,288,294,300,306,312,318,324,330,336,342,348,354,360,366,372,378,384,390,396,402,408,414,420,426,432,438,444,450,456,462,468,474,480,486,492,498,504,510,516,522,528,534,540,546,552,558,564,570,576,582,588,594,600,606,612,618,624,630,636,642,648,654,660,666,672,678,684,690,696,702,708,714,720,726,732,738,744,750,756,762,768,774,780,786,792,798,804,810,816,822,828,834,840,846,852,858,864,870,876,882,888,894,900,906,912,918,924,930,936,942,948,954,960,966,972,978,984,990,996,1002,1008,1014,1020,1026,1032,1038,1044,1050,1056,1062,1068,1074,1080,1086,1092,1098,1104,1110,1116,1122,1128,1134,1140,1146,1152,1158,1164,1170,1176,1182,1188,1194,1200,1206,1212,1218,1224,1230,1236,1242,1248,1254,1260,1266,1272,1278,1284,1290,1296,1302,1308,1314,1320,1326,1332,1338,1344,1350,1356,1362,1368,1374,1380,1386,1392,1398,1404,1410,1416,1422,1428,1434,1440,1446,1452,1458,1464,1470,1476,1482,1488,1494,1500,1506,1512,1518,1524,1530,1536,1542,1548},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864,868,872,876,880,884,888,892,896,900,904,908,912,916,920,924,928,932,936,940,944,948,952,956,960,964,968,972,976,980,984,988,992,996},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99,102,105,108,111,114,117,120,123,126,129,132,135,138,141,144,147,150,153,156,159,162,165,168,171,174,177,180,183,186,189,192,195,198,201,204,207,210,213,216,219,222,225,228,231,234,237,240,243,246,249,252,255,258,261,264,267,270,273,276,279,282,285,288,291,294,297,300,303,306,309,312,315,318,321,324,327,330,333,336,339,342,345,348,351,354,357,360,363,366,369,372,375,378,381,384,387,390,393,396,399,402,405,408,411,414,417,420,423,426,429,432,435,438,441,444,447,450,453,456,459,462,465,468,471,474,477,480,483,486,489,492,495,498,501,504,507,510,513,516,519,522,525,528,531,534,537,540,543,546,549,552,555,558,561,564,567,570,573,576,579,582,585,588,591,594,597,600,603,606,609,612,615,618,621,624,627,630,633,636,639,642,645,648,651,654,657,660,663,666,669,672,675},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864,868,872,876,880,884,888,892,896,900,904,908,912},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,24,36,48,60,72,84,96,108,120,132,144,156,168,180,192,204,216,228,240,252,264,276,288,300,312,324,336,348,360,372,384,396,408,420,432,444,456,468,480,492,504,516,528,540,552,564,576,588,600,612,624,636,648,660,672,684,696,708,720,732,744,756,768,780,792,804,816,828,840,852,864,876,888,900,912,924,936,948,960,972,984,996,1008,1020,1032,1044,1056,1068,1080,1092,1104,1116,1128,1140,1152,1164,1176,1188,1200,1212,1224,1236,1248,1260,1272,1284,1296,1308,1320,1332,1344,1356,1368,1380,1392,1404,1416,1428,1440,1452,1464,1476,1488,1500,1512,1524,1536,1548,1560,1572,1584,1596,1608,1620,1632,1644,1656,1668,1680,1692,1704},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136,144,152,160,168,176,184,192,200,208,216,224,232,240,248,256,264,272,280,288,296,304,312,320,328,336,344,352,360,368,376,384,392,400,408,416,424,432,440,448,456,464,472,480,488,496,504,512,520,528,536,544,552,560,568,576,584,592,600,608,616,624,632,640,648,656,664,672,680,688,696,704,712,720,728,736,744,752,760,768,776,784,792,800,808,816,824,832,840,848,856,864,872,880,888,896,904,912,920,928,936,944,952,960,968,976,984,992,1000,1008,1016,1024,1032,1040,1048,1056,1064,1072,1080,1088,1096},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138,144,150,156,162,168,174,180,186,192,198,204,210,216,222,228,234,240,246,252,258,264,270,276,282,288,294,300,306,312,318,324,330,336,342,348,354,360,366,372,378,384,390,396,402,408,414,420,426,432,438,444,450,456,462,468,474,480,486,492,498,504,510,516,522,528,534,540,546,552,558,564,570,576,582,588,594,600,606,612,618,624,630,636,642,648,654,660,666,672,678,684,690,696,702,708,714,720,726,732,738,744,750,756,762,768,774,780,786,792,798,804,810,816,822,828,834,840,846,852,858,864,870,876,882,888,894,900,906,912,918,924},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284}};
int C3[K][B]={{330,260,309,356,382,302,263,348,354,333},{442,371,352,438,461,454,378,320,323,416},{337,310,352,371,334,299,315,268,376,305},{703,676,719,600,621,779,807,692,627,545},{557,698,693,588,662,761,704,557,588,751},{336,355,336,467,326,403,406,400,454,339},{429,469,399,393,403,333,416,403,416,379},{375,345,345,448,305,381,378,308,323,393},{330,439,469,393,353,360,442,406,406,347},{466,469,414,373,449,490,480,421,500,511}};
int C4[S]={48,48,48,48,48,48};
int ODS[2][1]={{},{}};
int Hset[2][HWPN]={{0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19},{1,2,3,4,5,6,7,8,9,0,2,3,4,5,6,7,8,9,0,1,3,4,5,6,7,8,9,0,1,2,4,5,6,7,8,9,0,1,2,3,5,6,7,8,9,0,1,2,3,4,6,7,8,9,0,1,2,3,4,5,7,8,9,0,1,2,3,4,5,6,8,9,0,1,2,3,4,5,6,7,9,0,1,2,3,4,5,6,7,8,11,12,13,14,15,16,17,18,19,10,12,13,14,15,16,17,18,19,10,11,13,14,15,16,17,18,19,10,11,12,14,15,16,17,18,19,10,11,12,13,15,16,17,18,19,10,11,12,13,14,16,17,18,19,10,11,12,13,14,15,17,18,19,10,11,12,13,14,15,16,18,19,10,11,12,13,14,15,16,17,19,10,11,12,13,14,15,16,17,18}};

//input data ends here


double totalerr=0.00001; 
int BTN=0; 
int BTindex[B][T];
int HDTN=0;
vector<int> HDLEAD;
vector<int> HDFOLLOW;
vector<int> HDTIME;
int GTN=0;
vector<int> GTIN;
vector<int> GTOUT;
vector<int> GTTIME;

int HDSN[I];
vector<vector<int>> HDSET(I);
int TSdn[T]; 
vector<vector<int>> TSdex(T);
int LL=999999;
int PLL=999999;
int levels=0; 
double upperbound;
double totallb;  
double	pupperbound=PLL;
double	ptotallb=-PLL;
double totalgap;
int tmloc[2];
vector<int> nodenum;
vector<vector<vector<int>>>nodeindx;
vector<vector<double>> lowerbound;
vector<vector<vector<int>>> brcho(2); 
vector<vector<int>> brtype;  
vector<vector<int>> brnd1; 
vector<vector<int>> brnd2; 
int N;
int NN; 
int TON;
int PN;
int PNN;
int PTON;
vector <int> colves;
vector <int> colberth;
vector <double> colcost;
vector<vector<int>> coltimes(3); 
vector <int> pcolshift; 
vector <double> pcolcost; 
vector<int> pcollen; 
vector<vector<int>> pcoltasks;   
int plevels=0; 
double ptotalgap; 
int ptmloc[2]; 
vector<int> pnodenum;  
vector<double> pminlb;
vector<int> pmlloc;
vector<vector<vector<int>>> pnodeindx;
vector<vector<double>> plowerbound;
vector<vector<int>> pbrtype;
vector<vector<int>> pbrnd1;
vector<vector<int>> pbrnd2; 
int PSID[S][I]; 
int PIID[I+2][I+2];
int numused=0;
vector<int> usedcol;
vector<double> usedcolval;
int pnumused=0;
vector<int> pusedcol;
vector<double> pusedcolval;

ILOSTLBEGIN 
	IloObjective   Totalcost;
IloRangeArray  Vessel;
IloRangeArray  Berocu;
IloRangeArray  Hdway;
IloRangeArray  Noncro;
IloRangeArray  Bendcon; 

IloObjective   PTotalcost;
IloRangeArray  PTask;
IloRangeArray  PTask02;
double vesdual [K]; 
vector<double> berocudual;
vector<double> HDdual;
vector<double> noncrodual;

vector<double> ptaskdual;  
int SITN[S]; 
vector<vector<int>> SIS(S);
int nt1used[K];
int nt3used[K]; 
vector<vector<int>> usedt1(K); 
vector<vector<int>> usedt3(K);
int berused[K];
vector<vector<int>> usedbt(K); 
double BOCUV[B][T];
int BSEQ[K][B]; 
double T1result[K][T];
double T3result[K][T];
int ITN=0;
int Iset[I*T];
int Tset[I*T];
vector<double> ITres;
int VKB[K][B];
int VIT[I][T];
int OVIT[I][T];
extern const int TTRD=6;
int PRTN[TTRD];
vector<vector<int>> PVset(TTRD);
vector<vector<int>> PBset(TTRD);
int NCOLN[TTRD];
vector <vector <int>> prcolves(TTRD);
vector <vector <int>> prcolberth(TTRD); 
vector <vector <double>> prcolcost(TTRD); 
vector <vector<vector<int>>> prcoltimes(TTRD); 
vector <vector<vector<int>>> prcolshifts(TTRD);  
int PPRTN[TTRD];
vector<vector<int>> PPSset(TTRD);
vector <vector <int>> prpcolshift(TTRD); 
vector <vector <double>> prpcolcost(TTRD); 
vector <vector<int>> prpcollen(TTRD); 
vector <vector<vector<int>>> prpcoltasks(TTRD); 
int create=1;
double CRTLB=0;
double BVBD[B][K];
clock_t t_start,t_end,t_crt;


void PRLsetup(){ 
	for (int tt=0;tt!=TTRD;++tt){
		PRTN[tt]=0;
		prcoltimes[tt].resize(3);
		prcolshifts[tt].resize(2);
		PPRTN[tt]=0;
	}
	int basen=floor(double(K*B)/double(TTRD));
	for (int nn=0;nn!=TTRD;++nn){
		PRTN[nn]=basen;
	}
	int leftn=K*B-basen*TTRD;
	for (int nn=0;nn!=leftn;++nn){
		PRTN[nn]+=1;
	}
	int thetd=0;
	int theno=0;
	for (int k=0;k!=K;++k){ 
		for (int b=0;b!=B;++b){	
				PVset[thetd].resize(theno+1,k);
				PBset[thetd].resize(theno+1,b);
				theno+=1;
				if (theno>=PRTN[thetd]){
					thetd+=1;
					theno=0;
				}
		}	
	}
   	basen=floor(double(S)/double(TTRD));
	for (int nn=0;nn!=TTRD;++nn){
		PPRTN[nn]=basen;
	}
	leftn=S-basen*TTRD;
	for (int nn=0;nn!=leftn;++nn){
		PPRTN[nn]+=1;
	}
	thetd=0;
	theno=0;
	for (int s=0;s!=S;++s){
			PPSset[thetd].resize(theno+1,s);
			theno+=1;
			if (theno>=PPRTN[thetd]){
				thetd+=1;
				theno=0;
			}
	}	
}

void CGsetup(){
	for (int b=0;b!=B;++b){
		for (int t=0;t!=T;++t){
			BTindex[b][t]=-1; 
		}
	}
	for (int b=0;b!=B;++b){
		for (int t=0;t!=T;++t){
			BTindex[b][t]=-1; 
		}
	}
	int lasttime=-100;
	int firsttime=100000;
	for (int k=0;k!=K;++k){
		if (E[k][1]+D[k]>lasttime){
			lasttime=E[k][1]+D[k];
		}
		if (E[k][0]+D[k]<firsttime){
			firsttime=E[k][0]+D[k];
		}
	}
	int mgap=48;
	for (int b=0;b!=B;++b){
		int t=BRT[b];
		if (t<firsttime){
			t=firsttime;
		}
		while (t<=lasttime){
		       BTindex[b][t]=BTN; 
			   BTN+=1;
			   t+=mgap;
		}
	}
	for (int s=0;s!=S;++s){
		for (int t=ST[s][0];t<=ST[s][1];++t){
			TSdn[t]=0;
		}
	}
	for (int s=0;s!=S;++s){
		for (int t=ST[s][0];t<=ST[s][1];++t){
			TSdn[t]+=1;
			TSdex[t].resize(TSdn[t],s);
		}
	}
	for (int i=0;i!=I;++i){
		for (int t=E[i][0];t<=E[i][1];++t){
			OVIT[i][t]=1;
		}
	}    
	for (int i=K;i!=2*K;++i){
		for (int b=0;b!=B;++b){
			int timet=BRT[b];
			int edtime=HDT[b]; 
			if (HDT[b]!=-1){
				for (int tt=timet;tt<edtime;++tt){
					OVIT[i][tt]=0;}}
		}
	}
	for (int i=0;i!=K;++i){
		if (VLL[i]>=2){
			for (int b=0;b!=B;++b){
				int time02=Chaocu[b];
				if (time02!=-1){
					int timet=BRT[b];
					for (int t=timet;t<=time02-1;++t){
						OVIT[i][t]=0;
					}
				}
			}
		}
	}
	for (int i=0;i!=I;++i){
		for (int t=E[i][0];t<=E[i][1];++t){
			int doable=0;
			for (int n=0;n!=TSdn[t];++n){
				int thes=TSdex[t][n]; 
				if (BRK[thes][0]+D[I]<=t){
					doable=1;
					break;
				}
				if (t+D[i]<=BRK[thes][1]){
					doable=1;
					break;
				}
			}
			OVIT[i][t]=doable;
		}
	}
	for (int k=0;k!=K;++k){
		HDSN[k]=0;
		for (int h=0;h!=K;++h){
			if (k!=h){
				if (E[k][1]+F[k][h]-1>=E[h][0] && E[k][0]<=E[h][1]){
				HDSN[k]+=1;
				HDSET[k].resize(HDSN[k],h);
				}
			}
		}
	}
	for (int k=K;k!=I;++k){
		HDSN[k]=0;
		for (int h=K;h!=I;++h){
			if (k!=h){
				if (E[k][1]+F[k][h]-1>=E[h][0] && E[k][0]<=E[h][1]){
				HDSN[k]+=1;
				HDSET[k].resize(HDSN[k],h);
				}
			}
		}
	}
}

void inputData () {
	PRLsetup();
	CGsetup();
	upperbound=LL;
	totallb=-LL;
	for (int k=0;k!=K;++k){
		double BScost[B];
		for (int b=0;b!=B;++b){
			BScost[b]=C3[k][b];
		}
		for (int b=0;b!=B;++b){
			int theb=mathmin03(BScost,B);
			BSEQ[k][b]=theb;
			BScost[theb]=999999;
		}
	}
}

void Inicolload(IloModel model,IloNumVarArray x,int lel, int ind){
	IloEnv env = model.getEnv();
	IloInt s,i,j,t,k;  
	IloNumArray vescover(env, K);
	IloNumArray berocu(env,BTN);
    IloNumArray headway(env, HDTN);
	IloNumArray noncro(env, GTN);  
	for (j = 0; j < K; j++) { 
		for (k=0;k!=K;++k){vescover[k]=0;}
		for (i=0;i!=BTN;++i){berocu[i]=0;}
        for (i=0;i!=HDTN;++i){headway[i]=0;}
		for (i=0;i!=GTN;++i){noncro[i]=0;}
		vescover[j]=1;
		x.add(IloNumVar(Totalcost(C1[j]) + Vessel(vescover)+Berocu(berocu)+ Hdway(headway)+Noncro(noncro))); 
	}
	N=0; 
    NN=N; 
	TON=0;
	vector <int> hhcolves;
	vector <int> hhcolberth;  
	vector <double> hhcolcost;
	vector<vector<int>> hhcoltimes(3); 
	vector<vector<int>> hhcolshifts(2); 
	if (numused>0){
		for (int nn=0;nn!=numused;++nn){
			int thecol=usedcol[nn];
			int theves=colves[thecol];
			int theber=colberth[thecol];
			double thecost=colcost[thecol];
			int thet1=coltimes[0][thecol];
			int thet2=coltimes[1][thecol]; 
			int thet3=coltimes[2][thecol]; 
			TON+=1; 
			hhcolves.resize(TON,theves);
			hhcolberth.resize(TON,theber);
			hhcolcost.resize(TON,thecost);
			hhcoltimes[0].resize(TON,thet1);
			hhcoltimes[1].resize(TON,thet2);
			hhcoltimes[2].resize(TON,thet3);
			NN+=1;
		}
	}
	colves.swap(hhcolves);
	vector<int>().swap(hhcolves);
	colberth.swap(hhcolberth);
	vector<int>().swap(hhcolberth);
	colcost.swap(hhcolcost);
	vector<double>().swap(hhcolcost);
	for (int nn=0;nn!=3;++nn){
		coltimes[nn].swap(hhcoltimes[nn]);
		vector<int>().swap(hhcoltimes[nn]);
	}
	numused=0;
	vector<int>().swap(usedcol);
	vescover.end();
	berocu.end();
	headway.end();
	noncro.end();
}

double masterproblem (IloModel model,IloCplex lpsolver,IloNumVarArray x,int numsc) {
	IloEnv env = model.getEnv(); 
	double MVAL;
	double optvalue;
	IloInt j,k,i,t,t1;   
	IloNumArray vescover(env, K);    
	IloNumArray berocu(env,BTN);    
    IloNumArray headway(env, HDTN);
	IloNumArray noncro(env, GTN);   
	try{
		for (j = N; j < numsc; j++) {  
			int thecol=j;
			for (k=0;k!=K;++k){vescover[k]=0;}
			for (i=0;i!=BTN;++i){berocu[i]=0;}
			for (i=0;i!=HDTN;++i){headway[i]=0;}
			for (i=0;i!=GTN;++i){noncro[i]=0;}
			int theves=colves[thecol];
			vescover[theves]=1;
			int thet1=coltimes[0][thecol];
			 for (int nn=0;nn!=HDTN;++nn){
				 if (HDLEAD[nn]==theves){
					 int et1=thet1+F[theves][HDFOLLOW[nn]]-1;
					 if (et1>T-1){et1=T-1;}
					 if (thet1<=HDTIME[nn] && HDTIME[nn]<=et1){ 
					     headway[nn]+=1;
					 }
				 }
				 if (HDFOLLOW[nn]==theves){
					 if (HDTIME[nn]==thet1){
						 headway[nn]+=1;
					 }
				 }
			 }
			int thet3=coltimes[2][thecol];
			for (int nn=0;nn!=HDTN;++nn){
				 if (HDLEAD[nn]==theves+K){
					 int et3=thet3+F[theves+K][HDFOLLOW[nn]]-1; 
					 if (et3>T-1){et3=T-1;}
					 if (thet3<=HDTIME[nn] && HDTIME[nn]<=et3){ 
					     headway[nn]+=1;
					 }
				 }
				 if (HDFOLLOW[nn]==theves+K){
					 if (HDTIME[nn]==thet3){
						 headway[nn]+=1;
					 }
				 }
			 }
			for (int n=0;n!=GTN;++n){
				int thei=GTIN[n];
				int thej=GTOUT[n];
				if (theves==thei){ 
					int et01=thet1+D[theves]-1; 
					if (et01>T-1){et01=T-1;}
					if (thet1<=GTTIME[n] && GTTIME[n]<=et01){ 
						noncro[n]+=1;
					}			 
				}
				if (theves+K==thej){ 
					int et03=thet3+D[theves+K]-1; 
					if (et03>T-1){et03=T-1;}
					if (thet3<=GTTIME[n] && GTTIME[n]<=et03){ 
						noncro[n]+=1;
					}				 
				}
			}
			 int theber=colberth[thecol];
			 int thet2=coltimes[1][thecol];
			 int et2=thet3-1; 
			 for (t1=thet2;t1<=et2;++t1){
				 int theind=BTindex[theber][t1];
				 if (theind!=-1){
					 berocu[theind]=1;}
			 }
			double thecost=colcost[thecol];
			x.add(IloNumVar(Totalcost(colcost[thecol])+Vessel(vescover)+Berocu(berocu)+Hdway(headway)+Noncro(noncro))); 
		}
		{
			lpsolver.solve();
			optvalue=LL;
			if(lpsolver.getStatus() ==IloAlgorithm::Optimal){
				optvalue=lpsolver.getObjValue();
				vector<double>().swap(berocudual);
				berocudual.resize(BTN);
				vector<double>().swap(HDdual);
				HDdual.resize(HDTN);
				vector<double>().swap(noncrodual);
				noncrodual.resize(GTN);
				for (i = 0; i < K; i++) {
					vesdual[i] = lpsolver.getDual(Vessel[i]);
				}
				for (i=0;i<BTN; i++){
					berocudual[i]=lpsolver.getDual(Berocu[i]);
				}
				for (i = 0; i < HDTN; i++) {
					HDdual[i] = lpsolver.getDual(Hdway[i]);
				}
				for (i=0;i<GTN; i++){
					noncrodual[i]=lpsolver.getDual(Noncro[i]);
				}
			}
			MVAL=lpsolver.getObjValue();
		}
	}
	catch(IloException& ex){
		cerr << ex << endl;
	}
	catch(...){
		cerr << "Error..." << endl;
	}
	vescover.end();
	N=NN;
	vescover.end();
    headway.end();
	noncro.end();
	berocu.end();
	return MVAL;
}

void netload(int lel,int ind,int branch){
	for (int k=0;k!=K;++k){
		for (int b=0;b!=B;++b){
			VKB[k][b]=1; 
		}
	}
	for (int i=0;i!=I;++i){
		for (int t=E[i][0];t<=E[i][1];++t){
			VIT[i][t]=OVIT[i][t];
		}
	}    
	int thelel=lel;
	int theind=ind;
	int thebranch=branch;
	while (thelel!=-1){
		int thetype=brtype[thelel][theind]; 
		int then1=brnd1[thelel][theind];
		int then2=brnd2[thelel][theind];
		if (thebranch==0){
			if (thetype==1){
				VKB[then1][then2]=0;
			}
			if (thetype==2){ 
				VIT[then1][then2]=0;
			}

		}
		if (thebranch==1){
			if (thetype==1){
				for (int i=0;i!=then2;++i){
					VKB[then1][i]=0;
				}
				for (int i=then2+1;i!=B;++i){
					VKB[then1][i]=0;
				}
			}
			if (thetype==2){ 
				for (int i=E[then1][0];i!=then2;++i){
					VIT[then1][i]=0;
				}
				for (int i=then2+1;i<=E[then1][1];++i){
					VIT[then1][i]=0;
				}
			}
		}
		int tempind=nodeindx[thelel][theind][0];
		int tempbranch=nodeindx[thelel][theind][1];
		theind=tempind;
		thebranch=tempbranch;
		thelel-=1;
	}
}

void pathgen(int thev, int berth,int thread){  
	int thenewcol=0; 
	double acpbd=-0.0001;
	int CA[2]; 
	int CB[2];  
	double basecost=0; 
	basecost+=C3[thev][berth];
	basecost-=vesdual[thev];
	CA[0]=E[thev][0];
	CA[1]=E[thev][1];
	if (CA[0]<BRT[berth]-D[thev]){ 
		CA[0]=BRT[berth]-D[thev];
	}
	CB[0]=E[thev+K][0];
	CB[1]=E[thev+K][1];
	if (CB[0]<CA[0]+D[thev]+H[thev][berth]){
		CB[0]=CA[0]+D[thev]+H[thev][berth];
	}
	if (CA[1]>CB[1]-D[thev+K]-H[thev][berth]){
		CA[1]=CB[1]-D[thev+K]-H[thev][berth];
	}
	int flt1=-1; 
	int flt2=-1;  
	int flt3=-1;  
	double flcost=LL; 
	for (int t=CA[0];t<=CA[1];++t){
		if (VIT[thev][t]==0){
			continue;}
		int tt1=t;
		int tt2=t+D[thev];
		double trc=basecost; 
		trc+=C2[thev][tt1];
		for (int gg=0;gg!=HDTN;++gg){
			int thei=HDLEAD[gg];
			int thej=HDFOLLOW[gg];
			int thetime=HDTIME[gg];
			if (thev==thei){
				int et1=tt1+F[thev][thej]-1;
				if (et1>T-1){et1=T-1;}
				if (tt1<=thetime && thetime<=et1){
					trc-=HDdual[gg];
				}
			}
			if (thev==thej){ 
				if (tt1==thetime){
					trc-=HDdual[gg];
				}
			}
		}
		for (int gg=0;gg!=GTN;++gg){
			int thei=GTIN[gg];
			int thetm=GTTIME[gg];
			if (thev==thei){
				int etgg1=tt1+D[thev]-1;
				if (etgg1>T-1){
					etgg1=T-1;
				}
				if (tt1<=thetm && thetm<=etgg1){
				    trc-=noncrodual[gg];
				}	 
			}
		}
		double ftrc=trc;
		int eet3=tt2+H[thev][berth];
		for (int t3=eet3;t3<=CB[1];++t3){ 
			trc=ftrc;
			if (VIT[thev+K][t3]==0){
				continue;}
			int tt3=t3;
			trc+=C2[thev+K][tt3]; 
			for (int hh=tt2;hh<tt3;++hh){ 
				int theind=BTindex[berth][hh];
				trc-=berocudual[theind];
			}
			for (int gg=0;gg!=HDTN;++gg){
				int thei=HDLEAD[gg];
				int thej=HDFOLLOW[gg];
				int thetime=HDTIME[gg];
				if (thev+K==thei){ 
					int et3=tt3+F[thev+K][thej]-1;
					if (et3>T-1){et3=T-1;}
					if (tt3<=thetime && thetime<=et3){
						trc-=HDdual[gg];
					}
				}
				if (thev+K==thej){ 
					if (tt3==thetime){
						trc-=HDdual[gg];
					}
				}
			}
			for (int gg=0;gg!=GTN;++gg){
				int thej=GTOUT[gg];
				int thetm=GTTIME[gg];
				if (thev+K==thej){
					int etgg3=tt3+D[thev]-1;
					if (etgg3>T-1){
						etgg3=T-1;
					}
					if (tt3<=thetm && thetm<=etgg3){
						trc-=noncrodual[gg];
					}	 
				}
			}
			if (trc<flcost){
				flcost=trc; 
				flt1=tt1;
				flt2=tt2;
				flt3=tt3;
			}
		}
	}
	if (flcost<acpbd){ 
		CRTLB+=flcost;
		NCOLN[thread]+=1;
		prcolves[thread].resize(NCOLN[thread],thev);
		prcolberth[thread].resize(NCOLN[thread],berth);
		prcoltimes[thread][0].resize(NCOLN[thread],flt1);
		prcoltimes[thread][1].resize(NCOLN[thread],flt2);
		prcoltimes[thread][2].resize(NCOLN[thread],flt3);
		double comcost=0;
		comcost+=C2[thev][flt1]+C2[thev+K][flt3]+C3[thev][berth];
		prcolcost[thread].resize(NCOLN[thread],comcost);
	}
}

int colgen(int lel, int ind, int branch){
int newcol=0;	
for (int nn=0;nn!=TTRD;++nn){
	NCOLN[nn]=0;
	vector<int>().swap(prcolves[nn]);
	vector<int>().swap(prcolberth[nn]);
	vector<double>().swap(prcolcost[nn]);
	for (int mm=0;mm!=3;++mm){
		vector<int>().swap(prcoltimes[nn][mm]);
	}
	for (int mm=0;mm!=2;++mm){
		vector<int>().swap(prcolshifts[nn][mm]);
	}
} 
#pragma omp parallel sections num_threads(6)
			{
#pragma omp section
				{
					for (int mm=0;mm!=PRTN[0];++mm){
						int k=PVset[0][mm];
						int b=PBset[0][mm];
						if (VKB[k][b]==1){
							pathgen(k,b,0);}
					}
				}
#pragma omp section
				{
					for (int mm=0;mm!=PRTN[1];++mm){
						int k=PVset[1][mm];
						int b=PBset[1][mm];
						if (VKB[k][b]==1){
							pathgen(k,b,1);}
					}
				}
#pragma omp section
				{
					for (int mm=0;mm!=PRTN[2];++mm){
						int k=PVset[2][mm];
						int b=PBset[2][mm];
						if (VKB[k][b]==1){
							pathgen(k,b,2);}
					}
				}
#pragma omp section
				{
					for (int mm=0;mm!=PRTN[3];++mm){
						int k=PVset[3][mm];
						int b=PBset[3][mm];
						if (VKB[k][b]==1){
							pathgen(k,b,3);}
					}
				}			
#pragma omp section
				{
					for (int mm=0;mm!=PRTN[4];++mm){
						int k=PVset[4][mm];
						int b=PBset[4][mm];
						if (VKB[k][b]==1){
							pathgen(k,b,4);}
					}
				}			
#pragma omp section
				{
					for (int mm=0;mm!=PRTN[5];++mm){
						int k=PVset[5][mm];
						int b=PBset[5][mm];
						if (VKB[k][b]==1){
							pathgen(k,b,5);}
					}
				}									
			}
for (int thread=0;thread!=TTRD;++thread){
	newcol+=NCOLN[thread];
	for (int mm=0;mm!=NCOLN[thread];++mm){
		NN+=1; 
		TON+=1;
		int thev=prcolves[thread][mm];
		colves.resize(TON,thev);
		int berth=prcolberth[thread][mm];
		colberth.resize(TON,berth);
		int tt1=prcoltimes[thread][0][mm];
		coltimes[0].resize(TON,tt1);
		int tt2=prcoltimes[thread][1][mm];
		coltimes[1].resize(TON,tt2);
		int tt3=prcoltimes[thread][2][mm];
		coltimes[2].resize(TON,tt3);
		double thecost=prcolcost[thread][mm];
		colcost.resize(TON,thecost);
	}
} 
	return newcol;
}

void PCGsetup(int toadd){
	if (toadd==1){
		ITN=0;
		for (int k=0;k!=K;++k){
			for (int n=0;n!=nt1used[k]; ++n){
				int thet=usedt1[k][n];
				Iset[ITN]=k;
				Tset[ITN]=thet;
				ITN+=1;
			}
		}
		for (int k=0;k!=K;++k){
			for (int n=0;n!=nt3used[k]; ++n){
				int thet=usedt3[k][n];
				Iset[ITN]=k+K;
				Tset[ITN]=thet;
				ITN+=1;
			}
		}
	}
	InsertionSort(Tset,Iset,ITN); 
	vector<double>().swap(ITres);
	ITres.resize(ITN);
	for (int nn=0;nn!=ITN;++nn){
		int thei=Iset[nn];
		int thet=Tset[nn];
		if (thei<K){
			ITres[nn]=T1result[thei][thet];}
		else {
			ITres[nn]=T3result[thei-K][thet];
		}
	}
	vector<double>().swap(ptaskdual);
	ptaskdual.resize(ITN);
}

void Pshrink(){
	for (int s=0;s!=S;++s){
			SITN[s]=0;
	}
	for (int s=0;s!=S;++s){
		vector<int>().swap(SIS[s]);
	}
	for (int n=0;n!=ITN;++n){
		int thei=Iset[n];
		int thet=Tset[n];
		for (int m=0;m!=TSdn[thet];++m){
			int thes=TSdex[thet][m];
			SITN[thes]+=1;
			SIS[thes].resize(SITN[thes],n);
		}
	}
}

void PinputData (int toadd) {  
	PCGsetup(toadd);
	Pshrink();
	vector<int>().swap(pcolshift);	
	vector<double>().swap(pcolcost);	
	vector<int>().swap(pcollen);	
	for (int nn=0;nn!=PTON;++nn){
		vector<int>().swap(pcoltasks[nn]);}
	PTON=0;
}

void PInicolload(IloModel model,IloNumVarArray x,int lel, int ind){
	IloEnv env = model.getEnv(); 
	IloInt j,k;  
	IloNumArray taskcover(env, ITN);
	for (j = 0; j < ITN; j++) { 
		for (k=0;k!=ITN;++k){taskcover[k]=0;}
		taskcover[j]=1;
		double thecost=10000;
		x.add(IloNumVar(PTotalcost(thecost) + PTask(taskcover)+PTask02(taskcover)));
	}
	PN=0;
	PNN=PN;
}

double pmasterproblem (IloModel model,IloCplex lpsolver,IloNumVarArray x,int numsc) {
	IloEnv env = model.getEnv();
	double MVAL;
	double optvalue;
	IloInt j,k; 
	IloNumArray taskcover(env, ITN); 
	try{
		for (j = PN; j < numsc; j++) { 
			for (k=0;k!=ITN;++k){taskcover[k]=0;}
			int thecol=j; 
			int thelen=pcollen[thecol];
			for (int nn=0;nn!=thelen;++nn){
				int thect=pcoltasks[thecol][nn]; 
				if (thect!=-1){ 
					taskcover[thect]=1;
				} 
			}
			double thecost=pcolcost[thecol];
			x.add(IloNumVar(PTotalcost(pcolcost[thecol])+PTask(taskcover)+PTask02(taskcover))); 
		}
		{
			lpsolver.solve();
			optvalue=PLL;
			if(lpsolver.getStatus() ==IloAlgorithm::Optimal){
				optvalue=lpsolver.getObjValue();
				for (int gg=0;gg<ITN; ++gg){
					ptaskdual[gg]=lpsolver.getDual(PTask[gg])+lpsolver.getDual(PTask02[gg]);
				}
			}
			MVAL=lpsolver.getObjValue();
		}
	}
	catch(IloException& ex){
		cerr << ex << endl;
	}
	catch(...){
		cerr << "Error..." << endl;
	}
	PN=PNN;
	return MVAL;
}

void pnetload(int lel,int ind,int branch){ 
	for (int i=0;i!=I;++i){
		for (int s=0;s!=S;++s){
			PSID[s][i]=1;
		}
	}
	for (int i=0;i!=I+2;++i){
		for (int j=0;j!=I+2;++j){
			PIID[i][j]=1;
		}
	}
	int thelel=lel;
	int theind=ind;
	int thebranch=branch;
	while (thelel!=-1){
		int thetype=pbrtype[thelel][theind]; 
		int then1=pbrnd1[thelel][theind]; 
		int then2=pbrnd2[thelel][theind]; 
		if (thebranch==0){
			if (thetype==0){ 
				PSID[then1][then2]=0;
			}
			if (thetype==1){ 
				PIID[then1][then2]=0;
			}
		}
		if (thebranch==1){
			if (thetype==0){ 
				for (int s=0;s!=S;++s){
					if (s!=then1){
						PSID[s][then2]=0; 
					}
				}
			}
			if (thetype==1){ 
				if (then1!=I && then1!=I+1){
					for (int i=0;i!=then2;++i){
						PIID[then1][i]=0;
					}
					for (int i=then2+1;i!=I+2;++i){
						PIID[then1][i]=0;
					}}
				if (then2!=I && then2!=I+1){
					for (int i=0;i!=then1;++i){
						PIID[i][then2]=0;
					}
					for (int i=then1+1;i!=I+2;++i){
						PIID[i][then2]=0;
					}
				}
			}
		}
		int tempind=pnodeindx[thelel][theind][0];
		int tempbranch=pnodeindx[thelel][theind][1];
		theind=tempind;
		thebranch=tempbranch;
		thelel-=1;
	}
}

void ppathgen(int shift, int thread){ 
	double acpbd=-0.0001;
	double incubd=0; 
	double basecost=0; 
	basecost+=C4[shift]; 
	int tfln=0; 
	vector<int> ftset; 
	vector<double> flcost (ITN);
	vector<int> fllen(ITN);
	vector<vector<int>> flind(ITN);
	int LRT=BRK[shift][1];
	for (int nn=0;nn!=SITN[shift];++nn){
		int theind=SIS[shift][nn];
		int thei=Iset[theind];
		int thet=Tset[theind];
		if (PSID[shift][thei]==0){
			continue;
		}
		if (thet+D[thei]<=LRT){ 
			tfln+=1;
			ftset.resize(tfln,theind);
			fllen[theind]=1;
			flind[theind].resize(1,theind);
			flcost[theind]=-ptaskdual[theind];
			if (PIID[I+1][thei]==0){
				flcost[theind]=PLL;
			}
		}
		else {
			break;
		}
	}
	for (int ln=0;ln<tfln-1;++ln){
		int lind=ftset[ln];
		int ltask=Iset[lind];
		int ltime=Tset[lind];
		int llen=fllen[lind];
		double lcost=flcost[lind];
		for (int fn=ln+1;fn<tfln;++fn){ 
			int find=ftset[fn];
			int ftask=Iset[find];
			int ftime=Tset[find];
			if (PIID[ltask][ftask]==0){ 
				continue;
			}
			if (ltask!=ftask&&ltime+D[ltask]+Q[ltask][ftask]<=ftime){  
				if (lcost-ptaskdual[find]<flcost[find]){
					flcost[find]=lcost-ptaskdual[find];
					int flen=llen+1;
					fllen[find]=flen; 
					vector<int>().swap(flind[find]);
					for (int nn=0;nn!=llen;++nn){
						int temp=flind[lind][nn];
						flind[find].resize(nn+1,temp);
					}
					flind[find].resize(flen,find);
				}
			}
		}
	}
	int tbln=0;  
	vector<int> btset; 
	vector<double> blcost (ITN);
	vector<int> bllen(ITN);
	vector<vector<int>> blind(ITN); 
	int ERT=BRK[shift][0];
	for (int nn=0;nn!=SITN[shift];++nn){
		int theind=SIS[shift][nn]; 
		int thei=Iset[theind];
		int thet=Tset[theind];
		if (PSID[shift][thei]==0){
			continue;
		}
		int thetime=thet;
		if (thetime<ERT+D[I]){ 
			continue;
		}
		tbln+=1;
		btset.resize(tbln,theind);
		bllen[theind]=1;
		blind[theind].resize(1,theind);
		blcost[theind]=-ptaskdual[theind];
		if (PIID[theind][I+1]==0){ 
			blcost[theind]=PLL; 
		}
	}
	for (int fn=tbln-1;fn>=1;--fn){
		int find=btset[fn];
		int ftask=Iset[find];
		int ftime=Tset[find];
		int flen=bllen[find];
		double fcost=blcost[find];
		for (int ln=fn-1;ln>=0;--ln){ 
			int lind=btset[ln];
			int ltask=Iset[lind];
			int ltime=Tset[lind];
			if (PIID[ltask][ftask]==0){ 
				continue;
			}
			if (ltime+D[ltask]+Q[ltask][ftask]<=ftime){ 
				if (fcost-ptaskdual[lind]<blcost[lind]){
					blcost[lind]=fcost-ptaskdual[lind];
					int llen=flen+1;
					bllen[lind]=llen; 
					blind[lind].erase(blind[lind].begin(), blind[lind].end());
					vector<int>().swap(blind[lind]);
					blind[lind].resize(1,lind);
					for (int nn=1;nn<llen;++nn){
						int temp=blind[find][nn-1];
						blind[lind].resize(nn+1,temp);
					}
				}
			}
		}
	}
	int seft=-1; 
	int sebt=-1;
	double theminival=acpbd;
	for (int ln=0;ln!=tfln;++ln){
		int thelind=ftset[ln];
		int thelt=Iset[thelind];
		if (PIID[thelt][I]==0){ 
			continue;
		}
		double tempcost=basecost+flcost[thelind];
		if (theminival>tempcost){
			seft=thelind; 
			theminival=tempcost;
			sebt=-1;
		}
	}
	for (int fn=0;fn!=tbln;++fn){
		int thefind=btset[fn];
		int thebt=Iset[thefind];
		if (PIID[I][thebt]==0){
			continue;
		}
		double tempcost=basecost+blcost[thefind];
		if (theminival>tempcost){
			seft=-1;
			sebt=thefind; 
			theminival=tempcost;
		}
	}
	for (int ln=0;ln!=tfln;++ln){
		int thelind=ftset[ln];
		int thelt=Iset[thelind];
		int theltime=Tset[thelind];
		if (PIID[thelt][I]==0){ 
			continue;
		}
		int lrstime=theltime+D[thelt];
		int ltime=theltime;
		if (lrstime<BRK[shift][0]){
			lrstime=BRK[shift][0];
		}
		for (int fn=0;fn!=tbln;++fn){
			int thebind=btset[fn];
			int thebt=Iset[thebind];
			int theftime=Tset[thebind];
			if (PIID[I][thebt]==0){
				continue;
			}
			int brstime=theftime-D[I]; 
			if (brstime>BRK[shift][1]){
				brstime=BRK[shift][1];
			}
			if (lrstime>brstime){ 
				continue;
			}
			int ftime=theftime;
			if (thelt!=thebt&&ltime+D[thelt]+Q[thelt][thebt]<=ftime){  
				double tempcost=basecost+flcost[thelind]+blcost[thebind];
				if (theminival>tempcost){
					theminival=tempcost;
					seft=thelind;
					sebt=thebind;
				}
			}
		}
	}
	if (theminival<acpbd-0.0001){ 
		NCOLN[thread]+=1;
		prpcolshift[thread].resize(NCOLN[thread],shift);
		prpcoltasks[thread].resize(NCOLN[thread]);
		int templen=0;
		if (seft!=-1){
			for (int nn=0;nn!=fllen[seft];++nn){
			     templen+=1;
				 int tempind=flind[seft][nn];
				 prpcoltasks[thread][NCOLN[thread]-1].resize(templen,tempind);
			}
		}
		templen+=1;
		prpcoltasks[thread][NCOLN[thread]-1].resize(templen,-1);
		if (sebt!=-1){
			for (int nn=0;nn!=bllen[sebt];++nn){
				templen+=1;
				int tempind=blind[sebt][nn];
				prpcoltasks[thread][NCOLN[thread]-1].resize(templen,tempind);
			}
		}
		prpcollen[thread].resize(NCOLN[thread],templen);
		prpcolcost[thread].resize(NCOLN[thread],basecost);
	}
}

int pcolgen(int lel, int ind, int branch){ 
	int newcol=0;	
	for (int nn=0;nn!=TTRD;++nn){
		vector<int>().swap(prpcolshift[nn]);
		vector<double>().swap(prpcolcost[nn]);
		for (int mm=0;mm!=NCOLN[nn];++mm){
			vector<int>().swap(prpcoltasks[nn][mm]);
		}
		vector<int>().swap(prpcollen[nn]);
		NCOLN[nn]=0;
	} 
#pragma omp parallel sections num_threads(6)
	{
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[0];++mm){
				int s=PPSset[0][mm];
				if (SITN[s]>0){
					ppathgen(s,0);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[1];++mm){
				int s=PPSset[1][mm];
				if (SITN[s]>0){
					ppathgen(s,1);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[2];++mm){
				int s=PPSset[2][mm];
				if (SITN[s]>0){
					ppathgen(s,2);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[3];++mm){
				int s=PPSset[3][mm];
				if (SITN[s]>0){
					ppathgen(s,3);}
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[4];++mm){
				int s=PPSset[4][mm];
				if (SITN[s]>0){
					ppathgen(s,4);}	
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[5];++mm){
				int s=PPSset[5][mm];
				if (SITN[s]>0){
					ppathgen(s,5);}
			}
		}									
	}
	for (int thread=0;thread!=TTRD;++thread){
		newcol+=NCOLN[thread];
		for (int mm=0;mm!=NCOLN[thread];++mm){
			PNN+=1;
			PTON+=1;
			int shift=prpcolshift[thread][mm];
			pcolshift.resize(PTON,shift);
			double basecost=prpcolcost[thread][mm];
			pcolcost.resize(PTON,basecost);
			int templen=prpcollen[thread][mm];
			pcollen.resize(PTON,templen);
			pcoltasks.resize(PTON);
			for (int tt=0;tt!=templen;++tt){
			int theind= prpcoltasks[thread][mm][tt];
			pcoltasks[PTON-1].resize(tt+1,theind);
			}
		}
	} 
	return newcol;
}

double SPrimal( ){
	double uppsc=0; 
	for (int j=1; j<pnumused; j++)   
	{  
		double key = pusedcolval[j];  
		int i = j-1;  
		while (i>=0 && pusedcolval[i]<key)  
		{  
			pusedcolval[i+1] = pusedcolval[i];
			int temp=pusedcol[i+1];
			pusedcol[i+1]=pusedcol[i];
			pusedcol[i]=temp;
			i--;  
		}  
		pusedcolval[i+1] = key;  
	}  
	int Visted=0;
	for (int n=0;n!=pnumused;++n){
		int addable=0;
		int thecol=pusedcol[n];
		int thelen=pcollen[thecol];
		int theshift=pcolshift[thecol];
		for (int m=0;m!=thelen;++m){
			int theind=pcoltasks[thecol][m];
			if (theind!=-1){
				if (ITres[theind]>0.99){
					Visted+=1;
					addable=1;
					int thetask=Iset[theind];
					ITres[theind]=0;
				}
			}
		}
		if (addable==1){
			uppsc+=C4[theshift];
		}
		if (Visted>=ITN){
			break;
		}
	}
	if (Visted<ITN){
		for (int theind=0;theind!=ITN;++theind){
			if (ITres[theind]>0.99){ 
				int thetask=Iset[theind];
				int thetime=Tset[theind];
				double themcost=PLL;
				for (int mm=0;mm!=TSdn[thetime];++mm){
					int theshift=TSdex[thetime][mm];
					if (C4[theshift]<themcost){
						themcost=C4[theshift];
					}
				}
				uppsc+=themcost;
				Visted+=1;
			}
		}
	}
	return uppsc;
}

void pmastersolver(int lel, int ind, int branch){
	PinputData (create);
	PTON=0;
	vector<int>().swap(pcolshift);	
	vector<double>().swap(pcolcost);	
	vector<int>().swap(pcollen);	
	for (int nn=0;nn!=PNN;++nn){
		vector<int>().swap(pcoltasks[nn]);}
	pnetload(lel,ind,branch);
	IloEnv env;     
	IloModel msmodel(env);
	IloCplex lpsolver(msmodel);
	lpsolver.setOut(env.getNullStream());
	lpsolver.setParam(IloCplex::Threads, 1); 
	IloNumVarArray x(env); 
	IloInt i;   
	PTotalcost = IloAdd(msmodel, IloMinimize(env));
	IloNumArray taskreach(env, ITN);  
	for (i=0;i!=ITN;++i){taskreach[i]=ITres[i];}
	PTask = IloAdd(msmodel, IloRangeArray(env, taskreach, IloInfinity));
	PTask02 = IloAdd(msmodel, IloRangeArray(env, -IloInfinity, taskreach)); 
	PInicolload(msmodel,x,lel,ind);
	double lwbd;
	lwbd=pmasterproblem(msmodel,lpsolver,x,PNN);
	int ncs=pcolgen(lel,ind,branch);
	while (ncs>0){
		lwbd=pmasterproblem(msmodel,lpsolver,x,PNN);
		ncs=pcolgen(lel,ind,branch);
	}
	lwbd=ceil(lwbd);
	if (lwbd<pupperbound-0.01){
		double SIresult[S][I];
		double IIresult[I+2][I+2];
		for (int s=0;s!=S;++s){
			for (i=0;i!=I;++i){
				SIresult[s][i]=0;
			}
		}
		for (int i=0;i!=I+2;++i){
			for (int j=0;j!=I+2;++j){
				IIresult[i][j]=0;
			}
		}
		int intsol=1;
		pnumused=0;
		vector<int>().swap(pusedcol);
		vector<double>().swap(pusedcolval);
		int thetype=-1; 
		int thenode1=-1;
		int thenode2=-1;
		double minscore=0.49;
		double tempd=0;
		for (IloInt j = 0; j <PNN; j++) {  
			double trv=lpsolver.getValue(x[ITN+j]);		
			if (trv>0.01){ 
				if (trv<0.99){intsol=0;}  
				int h=int(j); 
				pnumused+=1;
				pusedcol.resize(pnumused,h);
				pusedcolval.resize(pnumused,trv);
			}
		}
		if (intsol==0 && thetype==-1){
			int shiftused[I];
			vector<vector<int>> usedshift(I); 
			int followers[I];
			vector<vector<int>> usedflw(I); 
			for (int k=0;k!=I;++k){
				shiftused[k]=0;
				followers[k]=0;
			}
			for (IloInt j = 0; j <PNN; j++) {
				double trv=lpsolver.getValue(x[ITN+j]);	
				if (trv>0.0001){
					int h=j;
					int theshift=pcolshift[h]; 
					int thelen=pcollen[h];
					int thelt=I+1; 
					for (int nn=0;nn!=thelen;++nn){
						int theind=pcoltasks[h][nn]; 
						int thect;
						if (theind!=-1){
							thect=Iset[theind];}
						else{
							thect=I;  
						}
						if (thect<I){
							if (SIresult[theshift][thect]==0){
								shiftused[thect]+=1;
								usedshift[thect].resize(shiftused[thect],theshift);
							}
							SIresult[theshift][thect]+=trv;
						}
						if (thelt<I){
							if (IIresult[thelt][thect]==0){
								followers[thelt]+=1;
								usedflw[thelt].resize(followers[thelt],thect);
							}
							IIresult[thelt][thect]+=trv;
						}
						thelt=thect;
					}
					if (thelt<I){
						if (IIresult[thelt][I+1]==0){
							followers[thelt]+=1;
							usedflw[thelt].resize(followers[thelt],I+1);
						}}
					IIresult[thelt][I+1]+=trv;
				}
			}
			for (int kk=0;kk!=I;++kk){
				for (int nn=0;nn!=shiftused[kk];++nn){
					int temp=usedshift[kk][nn];
					double trv=SIresult[temp][kk];
					if (trv>=0.5){
						tempd=trv-0.5;}
					else {
						tempd=0.5-trv;}
					if (minscore>tempd){ 
						minscore=tempd;
						thetype=0;
						thenode1=temp; 
						thenode2=kk; 
					}
					if (minscore<0.001){
						break;
					}
				}
				if (minscore<0.001){
					break;
				}
			}
			if (thetype==-1){
				for (int kk=0;kk!=I;++kk){
					for (int nn=0;nn!=followers[kk];++nn){
						int temp=usedflw[kk][nn];
						double trv=IIresult[kk][temp];
						if (trv>=0.5){
							tempd=trv-0.5;}
						else {
							tempd=0.5-trv;}
						if (minscore>tempd){ 
							minscore=tempd;
							thetype=1;
							thenode1=kk; 
							thenode2=temp; 
						}
						if (minscore<0.001){
							break;
						}
					}
					if (minscore<0.001){
						break;
					}
				}
			}
		}
		if (intsol!=1){ 
			int crtlel=lel+1;
			if (crtlel+1>plevels){ 
				plevels+=1;
				pnodenum.resize(plevels,0);   
				pnodeindx.resize(plevels);
				plowerbound.resize(plevels);
				pbrtype.resize(plevels);
				pbrnd1.resize(plevels);
				pbrnd2.resize(plevels);
				pminlb.resize(plevels,lwbd);   
				pmlloc.resize(plevels,0);
			}
			pnodenum[crtlel]+=1;
			int lenum=pnodenum[crtlel];
			pnodeindx[crtlel].resize(lenum);
			pnodeindx[crtlel][lenum-1].resize(1,ind);
			pnodeindx[crtlel][lenum-1].resize(2,branch);
			plowerbound[crtlel].resize(lenum,lwbd);
			if (lwbd<ptotallb){
				ptotallb=lwbd;
				ptmloc[0]=crtlel;
				ptmloc[1]=lenum-1;		
			}
			if (lwbd<pminlb[crtlel]){
				pminlb[crtlel]=lwbd;
				pmlloc[crtlel]=lenum-1;
			}
			pbrtype[crtlel].resize(lenum,thetype);
			pbrnd1[crtlel].resize(lenum,thenode1);
			pbrnd2[crtlel].resize(lenum,thenode2);
		}
		if (intsol==1){ 
			pupperbound=lwbd;
			cout<<"a new upper bound is found by branching"<<pupperbound<<endl;
		}
		if (intsol==0){
			int uppsc=SPrimal(); 
			if (pupperbound>uppsc){
			    pupperbound=uppsc;
				cout<<"a new upper bound is found by heuristic"<<pupperbound<<endl;
			}
		}
	}
	env.end();
}

double PPrimal( ){
	double theintsol=LL;
	int DVN=0;
		for (int j=1; j<numused; j++)  
		{  
			double key = usedcolval[j];  
			int i = j-1;  
			while (i>=0 && usedcolval[i]<key)  
			{  
				usedcolval[i+1] = usedcolval[i];
				int temp=usedcol[i+1];
				usedcol[i+1]=usedcol[i];
				usedcol[i]=temp;
				i--;  
			}  
			usedcolval[i+1] = key;  
		}  
		int feasi=1;
		ITN=0;
		vector<double>().swap(ITres);
		int VESDO[K];
		for (int k=0;k!=K;++k){
			VESDO[k]=0;
		}
		int BOSN[B];
		vector<vector<vector<int>>>BOSset(B); 
		for (int b=0;b!=B;++b){
			BOSN[b]=0; 
			BOSset[b].resize(2);
		}
		int INTN=0;
		vector<vector<int>> INTset(2);
		int OUTTN=0; 
		vector<vector<int>> OUTTset(2);
		int LINTN=0; 
		vector<vector<int>>LINTset(2); 
		int LOUTTN=0; 
		vector<vector<int>>LOUTTset(2); 
		double thecost=0;
		for (int n=0;n!=numused;++n){
			int thecol=usedcol[n]; 
			int theves=colves[thecol];
			if (VESDO[theves]==1){ 
				continue;
			}
			int theber=colberth[thecol]; 
			int theint=coltimes[0][thecol]; 
			int thebst=coltimes[1][thecol];
			int theoutt=coltimes[2][thecol];
			feasi=1;
			for (int itn=0;itn<INTN;++itn){
				feasi=0;
				int cves=INTset[0][itn];
				int cst=INTset[1][itn];
				int est=cst+F[cves][theves];
				int theinend=theint+F[theves][cves];
				if (est<=theint || cst>=theinend){
					feasi=1;
				}
				if (feasi==0){
					break;
				}
			}
			if (feasi==1){
				for (int otn=0;otn<OUTTN;++otn){
					feasi=0;
					int cves=OUTTset[0][otn];
					int cst=OUTTset[1][otn];
					int est=cst+F[cves+K][theves+K];
					int theoutend=theoutt+F[theves+K][cves+K];
					if (est<=theoutt || cst>=theoutend){
						feasi=1;
					}
					if (feasi==0){
						break;
					}
				}
			}
			if (feasi==1){
				for (int bn=0;bn<BOSN[theber];++bn){
					feasi=0;
					int cst=BOSset[theber][0][bn];
					int est=BOSset[theber][1][bn];
					if (est<=thebst || cst>=theoutt){
						feasi=1;
					}
					if (feasi==0){
						break;
					}
				}
			}
			if (feasi==1){
				if (VLL[theves]>=2){ 
					for (int cn=0; cn<LINTN;++cn){
						feasi=0;
						int cst=LINTset[0][cn];
						int est=LINTset[1][cn];
						int theinend=theint+D[theves];
						if (est<=theint || cst>=theinend){
							feasi=1;
						}
						if (feasi==0){
							break;
						}
					}
				}
			}
			if (feasi==1){
				if (VLL[theves]>=2){
					for (int cn=0; cn<LOUTTN;++cn){
						feasi=0;
						int cst=LOUTTset[0][cn];
						int est=LOUTTset[1][cn];
						int theinend=theoutt+D[theves+K];
						if (est<=theoutt || cst>=theinend){
							feasi=1;
						}
						if (feasi==0){
							break;
						}
					}
				}
			}
			if (feasi==1){
				VESDO[theves]=1;
				DVN+=1;
				BOSN[theber]+=1;
				BOSset[theber][0].resize(BOSN[theber],thebst);
				BOSset[theber][1].resize(BOSN[theber],theoutt);
				INTN+=1;
				INTset[0].resize(INTN,theves);
				INTset[1].resize(INTN,theint);
				Iset[ITN]=theves;
				Tset[ITN]=theint;
				ITN+=1;
				ITres.resize(ITN,1);
				OUTTN+=1;
				OUTTset[0].resize(OUTTN,theves);
				OUTTset[1].resize(OUTTN,theoutt);
				Iset[ITN]=theves+K;
				Tset[ITN]=theoutt;
				ITN+=1;
				ITres.resize(ITN,1);
				if (VLL[theves]>=2){
					LINTN+=1;
					LINTset[0].resize(LINTN,theoutt);
					LINTset[1].resize(LINTN,theoutt+D[theves+K]);
					LOUTTN+=1;
					LOUTTset[0].resize(LOUTTN,theint);
					LOUTTset[1].resize(LOUTTN,theint+D[theves]);
				}
				thecost+=colcost[thecol];
			}
			if (DVN>=K){
				break;
			}
		}
		if (DVN<K){  
			for (int k=0;k!=K;++k){
				if (VESDO[k]>0.99){continue;}
				int theves=k;
				int theberth=-1;
				int entime=-1;
				int lvtime=-1;
				int feasi=1;
				for (int theint=E[theves][0];theint<=E[theves][1];++theint){
					if (OVIT[theves][theint]==0){continue;}
					for (int theoutt=E[theves+K][0];theoutt<=E[theves+K][1];++theoutt){
						if (OVIT[K+theves][theoutt]==0){continue;}
						for (int itn=0;itn<INTN;++itn){
							feasi=0;
							int cves=INTset[0][itn];
							int cst=INTset[1][itn];
							int est=cst+F[cves][theves];
							int theinend=theint+F[theves][cves];
							if (est<=theint || cst>=theinend){
								feasi=1;
							}
							if (feasi==0){
								break;
							}
						}
						if (feasi==1){
							for (int otn=0;otn<OUTTN;++otn){
								feasi=0;
								int cves=OUTTset[0][otn];
								int cst=OUTTset[1][otn];
								int est=cst+F[cves+K][theves+K];
								int theoutend=theoutt+F[theves+K][cves+K];
								if (est<=theoutt || cst>=theoutend){
									feasi=1;
								}
								if (feasi==0){
									break;
								}
							}
						}
						if (feasi==1){
							if (VLL[theves]>=2){
								for (int cn=0; cn<LINTN;++cn){
									feasi=0;
									int cst=LINTset[0][cn];
									int est=LINTset[1][cn];
									int theinend=theint+D[theves];
									if (est<=theint || cst>=theinend){
										feasi=1;
									}
									if (feasi==0){
										break;
									}
								}
							}
						}
						if (feasi==1){
							if (VLL[theves]>=2){
								for (int cn=0; cn<LOUTTN;++cn){
									feasi=0;
									int cst=LOUTTset[0][cn];
									int est=LOUTTset[1][cn];
									int theinend=theoutt+D[theves+K];
									if (est<=theoutt || cst>=theinend){
										feasi=1;
									}
									if (feasi==0){
										break;
									}
								}
							}
						}
						if (feasi==1){
							for (int thb=0;thb!=B;++thb){
								int theber=BSEQ[theves][thb];
								feasi=1;
								if (theint+D[theves]<BRT[theber]){
									feasi=0;
									continue;
								}
								if (theint+D[theves]+H[theves][theber]>theoutt){
									feasi=0;
									continue;  
								}
								if (feasi==1){
									int thebst=theint+D[theves];
									for (int bn=0;bn<BOSN[theber];++bn){
										feasi=0;
										int cst=BOSset[theber][0][bn];
										int est=BOSset[theber][1][bn];
										if (est<=thebst || cst>=theoutt){
											feasi=1;
										}
										if (feasi==0){
											break;
										}
									}
								}
								if (feasi==1){
									theberth=theber;
									break;
								}
							}
						}
						if (feasi==1){
							lvtime=theoutt;
						    break;
						}
					}
					if (feasi==1){
						entime=theint;
						break;
					}
				}
				
				if (feasi==1){
					VESDO[theves]=1;
					DVN+=1;
					int thebst=entime+D[theves];
					BOSN[theberth]+=1;
					BOSset[theberth][0].resize(BOSN[theberth],thebst);
					BOSset[theberth][1].resize(BOSN[theberth],lvtime);
					INTN+=1;
					INTset[0].resize(INTN,theves);
					INTset[1].resize(INTN,entime);
					Iset[ITN]=theves;
					Tset[ITN]=entime;
					ITN+=1;
					ITres.resize(ITN,1);
					OUTTN+=1;
					OUTTset[0].resize(OUTTN,theves);
					OUTTset[1].resize(OUTTN,lvtime);
					Iset[ITN]=theves+K;
					Tset[ITN]=lvtime;
					ITN+=1;
					ITres.resize(ITN,1);
					if (VLL[theves]>=2){
						LINTN+=1;
						LINTset[0].resize(LINTN,lvtime);
						LINTset[1].resize(LINTN,lvtime+D[theves+K]);
						LOUTTN+=1;
						LOUTTset[0].resize(LOUTTN,entime);
						LOUTTset[1].resize(LOUTTN,entime+D[theves]);
					}
					thecost+=C2[theves][entime]+C2[K+theves][lvtime]+C3[theves][theberth];
				}	
			}
		}
		if (DVN==K){ 
			theintsol=thecost;
		}
	return theintsol;
}

int tracutsepe(){
	int feasi=1; 
	for (int k=0;k!=K;++k){
		for (int n=0;n!=berused[k];++n){
			int theb=usedbt[k][n];
			for (int m=0;m!=nt1used[k];++m){
				int thet=usedt1[k][m]+D[k];
				if (BOCUV[theb][thet]>1.001 && BTindex[theb][thet]==-1){
					BTindex[theb][thet]=BTN;
					BTN+=1;
					feasi=0;
				}
			}
			for (int m=0;m!=nt3used[k];++m){
				int thet=usedt3[k][m]-1;
				if (BOCUV[theb][thet]>1.001 && BTindex[theb][thet]==-1){
					BTindex[theb][thet]=BTN;
					BTN+=1;
					feasi=0;
				}
			}
		}
	}
	if (feasi==1){
		for (int k=0;k!=K;++k){
			int thei=k;
			for (int n=0;n!=HDSN[thei];++n){
				int thej=HDSET[thei][n];
				for (int m=0;m!=nt1used[thej];++m){
					int jt=usedt1[thej][m];
					double thehdval=T1result[thej][jt];
					int sit=jt-F[thei][thej]+1;
					if (sit<E[thei][0]){
						sit=E[thei][0];
					}
					int eit=jt;
					if (eit>E[thei][1]){
						eit=E[thei][1];
					}
					for (int tt=sit;tt<=eit;++tt){
						thehdval+=T1result[thei][tt];
					}
					if (thehdval>=1.0001){
						feasi=0;
						HDTN+=1;
						HDLEAD.resize(HDTN,thei);
						HDFOLLOW.resize(HDTN,thej);
						HDTIME.resize(HDTN,jt);	
					}
				}
			}
		}
		for (int k=0;k!=K;++k){
			int thei=k+K;
			for (int n=0;n!=HDSN[thei];++n){
				int thej=HDSET[thei][n];
				for (int m=0;m!=nt3used[thej-K];++m){
					int jt=usedt3[thej-K][m];
					double thehdval=T3result[thej-K][jt];
					int sit=jt-F[thei][thej]+1;
					if (sit<E[thei][0]){
						sit=E[thei][0];
					}
					int eit=jt;
					if (eit>E[thei][1]){
						eit=E[thei][1];
					}
					for (int tt=sit;tt<=eit;++tt){
						thehdval+=T3result[thei-K][tt];
					}
					if (thehdval>=1.0001){
						feasi=0;
						HDTN+=1;
						HDLEAD.resize(HDTN,thei);
						HDFOLLOW.resize(HDTN,thej);
						HDTIME.resize(HDTN,jt);	
					}
				}
			}
		}
	}
	if (feasi==1){
		for (int gg=0;gg!=NCPN;++gg){
			int thei=ODS[0][gg];
			int thej=ODS[1][gg];
			for (int m=0;m!=nt1used[thei];++m){
				int theit=usedt1[thei][m];
				int theiend=theit+D[thei]-1;
				if (theiend>T-1){
					theiend=T-1;
				}
				for (int tt=theit;tt<=theiend;++tt){
					double thetval=0;
					int theist=tt-D[thei]+1;
					if (theist<E[thei][0]){
						theist=E[thei][0];
					}
					for (int tt2=theist;tt2<=tt;++tt2){ 
						thetval+=T1result[thei][tt2];
					}
					int thejst=tt-D[thej]+1;
					if (thejst<E[thej][0]){
						thejst=E[thej][0];
					}
					for (int tt2=thejst;tt2<=tt;++tt2){ 
						thetval+=T3result[thej-K][tt2];
					}
					if (thetval>=1.0001){
						feasi=0;
						GTN+=1;
						GTIN.resize(GTN,thei);
						GTOUT.resize(GTN,thej);
						GTTIME.resize(GTN,tt);	
					}
				}

			}
		}
	}
	return feasi;
}

void mastersolver(int lel, int ind, int branch){  
	vector<int> crtfv; 
	vector<int> crtfb; 
	int crtfn=0; 
	int feasi=0;
	netload(lel,ind,branch);
	pnumused=0;
	pusedcol.erase(pusedcol.begin(),pusedcol.end()); 
	vector<int>().swap(pusedcol);
	pusedcolval.erase(pusedcolval.begin(),pusedcolval.end()); 
	vector<double>().swap(pusedcolval);
	double KBresult[K][B]; 
	double lwbd;
	int intsol=1; 
	TON=0;
	vector<int>().swap(colves);
	vector<int>().swap(colberth);
	vector<double>().swap(colcost);
	for (int nn=0;nn!=3;++nn){
		vector<int>().swap(coltimes[nn]);
	}
	numused=0;
	vector<int>().swap(usedcol);
	while(feasi==0){
		feasi=1; 
	IloEnv env;      
	IloModel msmodel(env);
	IloCplex lpsolver(msmodel);
	lpsolver.setOut(env.getNullStream());
	lpsolver.setParam(IloCplex::Threads, 1); 
	IloNumVarArray x(env);
	IloInt i;   
	Totalcost = IloAdd(msmodel, IloMinimize(env));
	IloNumArray vesreach(env, K); 
	for (i=0;i!=K;++i){vesreach[i]=1;} 
	Vessel = IloAdd(msmodel, IloRangeArray(env, vesreach, IloInfinity));
	IloNumArray flheadway(env, HDTN); 
	for (i=0;i!=HDTN;++i){flheadway[i]=1;} 
	Hdway= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, flheadway));
	IloNumArray bicross(env, GTN); 
	for (i=0;i!=GTN;++i){bicross[i]=1;} 
	Noncro= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, bicross));  
	IloNumArray berthtime(env, BTN); 
	for (i=0;i!=BTN;++i){berthtime[i]=1;} 
	Berocu= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, berthtime)); 
	Inicolload(msmodel,x,lel,ind);
	lwbd=masterproblem(msmodel,lpsolver,x,NN); 
	int ncs=colgen(lel,ind,branch);
	while (ncs>0){
		lwbd=masterproblem(msmodel,lpsolver,x,NN);
		CRTLB=lwbd;
		ncs=colgen(lel,ind,branch);
		for (int bb=0;bb!=B;++bb){
			for (int kk=0;kk!=K;++kk){
				if (VKB[kk][bb]==1 && ceil(CRTLB+BVBD[bb][kk]-0.01)>=upperbound){
					VKB[kk][bb]=0;
					crtfn+=1;
					crtfv.resize(crtfn,kk);
					crtfb.resize(crtfn,bb);
				}
			}
		}
	}
	lwbd=ceil(lwbd-0.01);
	if (lwbd<=upperbound){
		for (int k1=0;k1!=K;++k1){
			vector<int>().swap(usedbt[k1]);
			for (int b=0;b!=B;++b){
				KBresult[k1][b]=0;
			}
		}
		for (int k=0;k!=K;++k){
			berused[k]=0;
			nt1used[k]=0;
			vector<int>().swap(usedt1[k]);
			nt3used[k]=0;
			vector<int>().swap(usedt3[k]);
		}
		for (int b=0;b!=B;++b){
			for (int t1=0;t1!=T;++t1){
				BOCUV[b][t1]=0;}
		}
		for (int k1=0;k1!=K;++k1){
			for (int t1=0;t1!=T;++t1){
				T1result[k1][t1]=0;
				T3result[k1][t1]=0;
			}
		}
		for (IloInt j = 0; j <NN; j++) {
			double trv=lpsolver.getValue(x[K+j]);
			if (trv>0.001){
				if (trv<0.99){intsol=0;}
				int h=j;
				numused+=1;
				usedcol.resize(numused,h);	
				usedcolval.resize(numused,trv);
				int theves=colves[h];
				int theber=colberth[h];
				int tt1=coltimes[0][h];
				int tt2=coltimes[1][h];
				int tt3=coltimes[2][h];
				if (KBresult[theves][theber]==0){
					berused[theves]+=1;
					usedbt[theves].resize(berused[theves],theber);}
				KBresult[theves][theber]+=trv;
				for (int tt=tt2;tt<=tt3;++tt){
					BOCUV[theber][tt]+=trv;}
				if (T1result[theves][tt1]==0){
					nt1used[theves]+=1;
					usedt1[theves].resize(nt1used[theves],tt1);}
				T1result[theves][tt1]+=trv;
				if (T3result[theves][tt3]==0){
					nt3used[theves]+=1;
					usedt3[theves].resize(nt3used[theves],tt3);}
				T3result[theves][tt3]+=trv;
			}
		}
		int trafeasi=tracutsepe();
		feasi=trafeasi; 
		env.end();
		if (trafeasi==1){
			int thetype=-1;
			int then1=-1;
			int then2=-1;
			double minscore=0.49;
			double tempd=0;
			if (intsol==0){
				for (int kk=0;kk!=K;++kk){
					for (int nn=0;nn!=berused[kk];++nn){
						int tempber=usedbt[kk][nn];
						double trv=KBresult[kk][tempber];
						if (trv>=0.5){
							tempd=trv-0.5;}
						else {
							tempd=0.5-trv;}
						if (minscore>tempd){ 
							minscore=tempd;
							thetype=1; 
							then1=kk;
							then2=tempber;
						}
						if (minscore<0.001){
							break;
						}
					}
					if (minscore<0.001){
						break;
					}
				}
				if (thetype==-1){ 
					for (int kk=0;kk!=K;++kk){
						for (int nn=0;nn!=nt1used[kk];++nn){
							int tempt1=usedt1[kk][nn];
							double trv=T1result[kk][tempt1];
							if (trv>=0.5){
								tempd=trv-0.5;}
							else {
								tempd=0.5-trv;}
							if (minscore>tempd){
								minscore=tempd;
								thetype=2; 
								then1=kk;
								then2=tempt1;
							}
							if (minscore<0.001){
								break;
							}
						}
						if (minscore<0.001){
							break;
						}
					}
				}
				if (thetype==-1){
					for (int kk=0;kk!=K;++kk){
						for (int nn=0;nn!=nt3used[kk];++nn){
							int tempt3=usedt3[kk][nn];
							double trv=T3result[kk][tempt3];
							if (trv>=0.5){
								tempd=trv-0.5;}
							else {
								tempd=0.5-trv;}
							if (minscore>tempd){ 
								minscore=tempd;
								thetype=2; 
								then1=kk+K;
								then2=tempt3;
							}
							if (minscore<0.001){
								break;
							}
						}
						if (minscore<0.001){
							break;
						}
					}
				}
			}
			if (intsol!=1){
				int crtlel=lel+1;
				if (crtlel+1>levels){
					levels+=1;
					nodenum.resize(levels,0);    
					nodeindx.resize(levels);
					lowerbound.resize(levels);
					brcho[0].resize(levels);
					brcho[1].resize(levels);
					brnd1.resize(levels);
					brtype.resize(levels);
					brnd2.resize(levels);
				}
				nodenum[crtlel]+=1;
				int lenum=nodenum[crtlel];
				nodeindx[crtlel].resize(lenum);
				nodeindx[crtlel][lenum-1].resize(1,ind); 
				nodeindx[crtlel][lenum-1].resize(2,branch);
				lowerbound[crtlel].resize(lenum,lwbd);
				brcho[0][crtlel].resize(lenum,1);
				brcho[1][crtlel].resize(lenum,1);
				brtype[crtlel].resize(lenum,thetype);
				brnd1[crtlel].resize(lenum,then1);
				brnd2[crtlel].resize(lenum,then2);
			}
			if (intsol==1){ 
				upperbound=lwbd;
				create=1;
				cout<<"a new upper bound is found by branching"<<upperbound<<endl;
			}
			if (intsol==0){ 
				int thetemp=PPrimal();
				if (thetemp<upperbound){
					upperbound=thetemp;
					create=0;
					cout<<"a new upper bound is found by heuristic"<<upperbound<<endl;}
			}
		}
	}
	}
}

void nodebranch(){ 
	int uptime=3600;
	int fnode;               
	int flayer;             
	int ffind=0;           
	while(1){
		totallb=upperbound;
		int tnn=0; 
		vector<int> opennd; 
		vector<int> openlv;
		for (int ll=0;ll!=levels;++ll){
			int tndn=nodenum[ll];
			for (int nn=0;nn!=tndn;++nn){
				double thelb=lowerbound[ll][nn];
				if (thelb<upperbound-0.001){
					if (brcho[0][ll][nn]==0 && brcho[1][ll][nn]==0){ 
						lowerbound[ll][nn]=LL;
					}
					else {
						tnn+=1;
						openlv.resize(tnn,ll);
						opennd.resize(tnn,nn);
						if (thelb<totallb){
							totallb=thelb;
						}
					}	
				}
			}
		}
		totalgap=100*(upperbound-totallb)/totallb;
		cout << "the optimality gap is:"<<totalgap<<"%"<<endl;
		t_crt=clock();
		if (totalgap<=totalerr){
			cout<<"optimality gap reached"<<endl;
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			break;
		}
		if (t_crt-t_start>=uptime*1000){
			cout<<"Time limit reached"<<endl;
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			break;
		}
		if (tnn==0){
			cout<<"all nodes have been closed"<<endl;
			t_crt=clock();
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			break;
		}
		double thelb=LL-10;
		if (tnn>0){ 
			flayer=-10;
			fnode=-10;
			for (int mm=0;mm!=tnn;++mm){
				int templv=openlv[mm];
				int tempnd=opennd[mm];
				if (brcho[0][templv][tempnd]==1 || brcho[1][templv][tempnd]==1){
					double templb=lowerbound[templv][tempnd];
					if (thelb>templb){
						thelb=templb;
						flayer=templv;
						fnode=tempnd;
					}
				}
				if (thelb==totallb){
					break;
				}
			}
			if (fnode!=-10){ 
				if (brcho[0][flayer][fnode]==1){
					brcho[0][flayer][fnode]=0;
					cout<<"0-branch on node["<<flayer<<"]["<<fnode<<"]"<<endl;
					mastersolver (flayer,fnode,0); 
					}
				if (brcho[1][flayer][fnode]==1){
					brcho[1][flayer][fnode]=0;
					cout<<"1-branch on node["<<flayer<<"]["<<fnode<<"]"<<endl;
					mastersolver (flayer,fnode,1);
					}
			}
		}
	}
	cout << endl;
	cout << endl;
	cout << "the final optimality gap is:"<<totalgap<<"%"<<endl;
	cout << endl;
}

void pnodebranch(){ 
	int flayer;
	int fnode;               
	int ffind=0;           
	if (plevels>0){
		while(1){
			ffind+=1;
			fnode=-10;
			double tempallb=pupperbound-0.01;
			for (int ll=0;ll!=plevels;++ll){
				for (int h5=0; h5!=pnodenum[ll];++h5){   
					if (plowerbound[ll][h5]<tempallb){
						tempallb=plowerbound[ll][h5];
						flayer=ll;
						fnode=h5;}
				}
			}
			if (fnode==-10){
				break;
			}
			plowerbound[flayer][fnode]=PLL;
			pmastersolver (flayer, fnode, 0);
			pmastersolver (flayer, fnode, 1); 
		}
	}
	cout << endl;
	cout << endl;
	cout << "the optimality gap is:"<<ptotalgap<<"%"<<endl;
	cout << endl;
}

void solvebap(){
	inputData();
	mastersolver(-1,-1,-1);
	nodebranch();
	pmastersolver(-1,-1,-1);
	pnodebranch();
}

void reswrite(){
	cout<<"Total cost="<<pupperbound+upperbound<<endl;
	cout<<"Time(ms)="<<(t_end-t_start)<<endl;
}
int main (int argc, char **argv) {
	t_start=clock();
	cout << "formulation" << endl;
	solvebap();
	t_end =clock();
	cout << "succeeded" << endl;
	reswrite();
	return 0;
}
