#include <ilcplex/ilocplex.h>   /* cplex */     
#include <vector>              
#include <omp.h>               /* parallel */
#include "Selfmath.h"

namespace patch {template < typename T > std::string to_string( const T& n ){std::ostringstream stm; stm << n; return stm.str() ;}}

using namespace std;
////////////////////////////////////////////////////////
//                                                    //
// Source CPP Code for the the TPBC Algorithm 
// Vessel Service Planning in Seaports, Operations Research
//                                                  
// Authors: Lingxiao Wu, Yossiri Adulyasak, Jean-François Cordeau, Shuaian Wang 
///////////////////////////////////////////////////////

//input data starts here

extern const int S = 6;
extern const int K =10;
extern const int T = 288;
extern const int B = 10;
extern const int I = 20;
extern const int NCPN = 0;
extern const int HWPN = 180;
int BRT[B]={0,14,0,21,6,47,20,0,22,44};
int Chaocu[B]={-1,-1,-1,-1,-1,-1,-1,-1,-1,51};
int HDT[B]={-1,15,-1,22,7,48,21,-1,23,45};
int E[I][2]={{0,39},{0,28},{23,71},{29,77},{38,86},{62,110},{87,135},{93,141},{101,149},{140,188},{59,107},{71,119},{83,131},{145,193},{150,198},{133,181},{160,208},{161,209},{174,222},{216,264}};
int BRK[S][2]={{14,34},{62,82},{110,130},{158,178},{206,226},{254,274}};
int VLL[K]={0,0,0,2,1,1,0,0,0,0};
int F[I][I]={{0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0}};
int D[I+1]={7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,6};
int H[K][B]={{52,52,52,52,52,52,52,52,52,52},{64,64,64,64,64,64,64,64,64,64},{53,53,53,53,53,53,53,53,53,53},{109,109,109,109,109,109,109,109,109,109},{105,105,105,105,105,105,105,105,105,105},{64,64,64,64,64,64,64,64,64,64},{66,66,66,66,66,66,66,66,66,66},{61,61,61,61,61,61,61,61,61,61},{66,66,66,66,66,66,66,66,66,66},{69,69,69,69,69,69,69,69,69,69}};
int Q[I+1][I+1]={{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};
int ST[S][2]={{0,47},{48,95},{96,143},{144,191},{192,239},{240,287}};
int C1[K]={50000,50000,50000,50000,50000,50000,50000,50000,50000,50000};
int C2[I][T]={{0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,524,526,528,530,532,534,536,538,540,542,544,546,548,550,552,554,556,558,560,562,564,566,568,570,572,574},{0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,524,526,528,530,532,534,536,538,540,542,544,546,548,550,552,554,556,558,560,562,564,566,568,570,572,574},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,524,526,528},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138,144,150,156,162,168,174,180,186,192,198,204,210,216,222,228,234,240,246,252,258,264,270,276,282,288,294,300,306,312,318,324,330,336,342,348,354,360,366,372,378,384,390,396,402,408,414,420,426,432,438,444,450,456,462,468,474,480,486,492,498,504,510,516,522,528,534,540,546,552,558,564,570,576,582,588,594,600,606,612,618,624,630,636,642,648,654,660,666,672,678,684,690,696,702,708,714,720,726,732,738,744,750,756,762,768,774,780,786,792,798,804,810,816,822,828,834,840,846,852,858,864,870,876,882,888,894,900,906,912,918,924,930,936,942,948,954,960,966,972,978,984,990,996,1002,1008,1014,1020,1026,1032,1038,1044,1050,1056,1062,1068,1074,1080,1086,1092,1098,1104,1110,1116,1122,1128,1134,1140,1146,1152,1158,1164,1170,1176,1182,1188,1194,1200,1206,1212,1218,1224,1230,1236,1242,1248,1254,1260,1266,1272,1278,1284,1290,1296,1302,1308,1314,1320,1326,1332,1338,1344,1350,1356,1362,1368,1374,1380,1386,1392,1398,1404,1410,1416,1422,1428,1434,1440,1446,1452,1458,1464,1470,1476,1482,1488,1494,1500,1506,1512,1518,1524,1530,1536,1542,1548},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864,868,872,876,880,884,888,892,896,900,904,908,912,916,920,924,928,932,936,940,944,948,952,956,960,964,968,972,976,980,984,988,992,996},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99,102,105,108,111,114,117,120,123,126,129,132,135,138,141,144,147,150,153,156,159,162,165,168,171,174,177,180,183,186,189,192,195,198,201,204,207,210,213,216,219,222,225,228,231,234,237,240,243,246,249,252,255,258,261,264,267,270,273,276,279,282,285,288,291,294,297,300,303,306,309,312,315,318,321,324,327,330,333,336,339,342,345,348,351,354,357,360,363,366,369,372,375,378,381,384,387,390,393,396,399,402,405,408,411,414,417,420,423,426,429,432,435,438,441,444,447,450,453,456,459,462,465,468,471,474,477,480,483,486,489,492,495,498,501,504,507,510,513,516,519,522,525,528,531,534,537,540,543,546,549,552,555,558,561,564,567,570,573,576,579,582,585,588,591,594,597,600,603,606,609,612,615,618,621,624,627,630,633,636,639,642,645,648,651,654,657,660,663,666,669,672,675},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864,868,872,876,880,884,888,892,896,900,904,908,912},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,24,36,48,60,72,84,96,108,120,132,144,156,168,180,192,204,216,228,240,252,264,276,288,300,312,324,336,348,360,372,384,396,408,420,432,444,456,468,480,492,504,516,528,540,552,564,576,588,600,612,624,636,648,660,672,684,696,708,720,732,744,756,768,780,792,804,816,828,840,852,864,876,888,900,912,924,936,948,960,972,984,996,1008,1020,1032,1044,1056,1068,1080,1092,1104,1116,1128,1140,1152,1164,1176,1188,1200,1212,1224,1236,1248,1260,1272,1284,1296,1308,1320,1332,1344,1356,1368,1380,1392,1404,1416,1428,1440,1452,1464,1476,1488,1500,1512,1524,1536,1548,1560,1572,1584,1596,1608,1620,1632,1644,1656,1668,1680,1692,1704},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136,144,152,160,168,176,184,192,200,208,216,224,232,240,248,256,264,272,280,288,296,304,312,320,328,336,344,352,360,368,376,384,392,400,408,416,424,432,440,448,456,464,472,480,488,496,504,512,520,528,536,544,552,560,568,576,584,592,600,608,616,624,632,640,648,656,664,672,680,688,696,704,712,720,728,736,744,752,760,768,776,784,792,800,808,816,824,832,840,848,856,864,872,880,888,896,904,912,920,928,936,944,952,960,968,976,984,992,1000,1008,1016,1024,1032,1040,1048,1056,1064,1072,1080,1088,1096},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138,144,150,156,162,168,174,180,186,192,198,204,210,216,222,228,234,240,246,252,258,264,270,276,282,288,294,300,306,312,318,324,330,336,342,348,354,360,366,372,378,384,390,396,402,408,414,420,426,432,438,444,450,456,462,468,474,480,486,492,498,504,510,516,522,528,534,540,546,552,558,564,570,576,582,588,594,600,606,612,618,624,630,636,642,648,654,660,666,672,678,684,690,696,702,708,714,720,726,732,738,744,750,756,762,768,774,780,786,792,798,804,810,816,822,828,834,840,846,852,858,864,870,876,882,888,894,900,906,912,918,924},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284}};
int C3[K][B]={{330,260,309,356,382,302,263,348,354,333},{442,371,352,438,461,454,378,320,323,416},{337,310,352,371,334,299,315,268,376,305},{703,676,719,600,621,779,807,692,627,545},{557,698,693,588,662,761,704,557,588,751},{336,355,336,467,326,403,406,400,454,339},{429,469,399,393,403,333,416,403,416,379},{375,345,345,448,305,381,378,308,323,393},{330,439,469,393,353,360,442,406,406,347},{466,469,414,373,449,490,480,421,500,511}};
int C4[S]={48,48,48,48,48,48};
int ODS[2][1]={{},{}};
int Hset[2][HWPN]={{0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19},{1,2,3,4,5,6,7,8,9,0,2,3,4,5,6,7,8,9,0,1,3,4,5,6,7,8,9,0,1,2,4,5,6,7,8,9,0,1,2,3,5,6,7,8,9,0,1,2,3,4,6,7,8,9,0,1,2,3,4,5,7,8,9,0,1,2,3,4,5,6,8,9,0,1,2,3,4,5,6,7,9,0,1,2,3,4,5,6,7,8,11,12,13,14,15,16,17,18,19,10,12,13,14,15,16,17,18,19,10,11,13,14,15,16,17,18,19,10,11,12,14,15,16,17,18,19,10,11,12,13,15,16,17,18,19,10,11,12,13,14,16,17,18,19,10,11,12,13,14,15,17,18,19,10,11,12,13,14,15,16,18,19,10,11,12,13,14,15,16,17,19,10,11,12,13,14,15,16,17,18}};

//input data ends here


double uptime=3600; 
double totalerr=0.00001;

int BTN=0; 
int BTindex[B][T];
int GTN=0;
int GTindex[NCPN+1][T];
int HTN=0;
int HTindex[HWPN][T];

int TSdn[T]; 
vector<vector<int>> TSdex(T); 
int LL=999999;
int PLL=999999;
double Vescost=LL;
double totallb;  
double	PLcost=PLL;
double totalgap;
double upperbound=LL;
int N; 
int NN;
int TON; 
int PN; 
int PNN;
int PTON; 

vector <int> colves;   
vector <int> colberth; 
vector <double> colcost;  
vector<vector<int>> coltimes(3); 
int FIXN=0;
vector <int> FIXcolves; 
vector <int> FIXcolberth;
vector <double> FIXcolcost;
vector<vector<int>> FIXcoltimes(3);   
vector <int> pcolshift;
vector <double> pcolcost;
vector<int> pcollen;
vector<vector<int>> pcoltasks;   
int PFIXN=0;
vector <int> FIXpcolshift;
vector <double> FIXpcolcost;
vector<int> FIXpcollen; 
vector<vector<int>> FIXpcoltasks;  
ILOSTLBEGIN 
IloObjective   Totalcost;
IloRangeArray  Vessel;
IloRangeArray  Berocu;
IloRangeArray  Hdway;
IloRangeArray  Noncro;
IloRangeArray  Bendcon; 
IloRangeArray  ENcon; 
IloRangeArray  FIXcon; 
IloObjective   PTotalcost;
IloRangeArray  PTask;
IloRangeArray  PTask02;
IloRangeArray  PFIXcon;
double vesdual [K];
vector<double> berocudual;
vector<double> hdwaydual;
vector<double> noncrodual;
vector<double> bdsdual;
vector<double> ptaskdual;  
int SITN[S]; 
vector<vector<int>> SIS(S);
int nt1used[K];
int nt3used[K]; 
vector<vector<int>> usedt1(K); 
vector<vector<int>> usedt3(K);

double T1result[K][T];
double T3result[K][T];
int ITN=0;
int Iset[I*T];
int Tset[I*T];
vector<double> ITres;

int OVIT[I][T];
int BDN=0; 
int TBDN=0;
int BDBN[I][T];
vector<vector<vector<int>>> BDindset(I);
vector<vector<vector<double>>> BDset(I); 
extern const int TTRD=6; 
int PRTN[TTRD];
vector<vector<int>> PVset(TTRD);
vector<vector<int>> PBset(TTRD);
int NCOLN[TTRD];
vector <vector <int>> prcolves(TTRD);  
vector <vector <int>> prcolberth(TTRD); 
vector <vector <double>> prcolcost(TTRD); 
vector <vector<vector<int>>> prcoltimes(TTRD);  

int PPRTN[TTRD];
vector<vector<int>> PPSset(TTRD);
vector <vector <int>> prpcolshift(TTRD);   
vector <vector <double>> prpcolcost(TTRD); 
vector <vector<int>> prpcollen(TTRD);  
vector <vector<vector<int>>> prpcoltasks(TTRD);  

clock_t t_start,t_end,t_crt; 
double rtobj=1; 
int mintsol=1; 
int Pintsol=1;

void PRLsetup(){
	for (int tt=0;tt!=TTRD;++tt){
		PRTN[tt]=0;
		prcoltimes[tt].resize(3);
		PPRTN[tt]=0;
	}
	int basen=floor(double(K*B)/double(TTRD));
	for (int nn=0;nn!=TTRD;++nn){
		PRTN[nn]=basen;
	}
	int leftn=K*B-basen*TTRD;
	for (int nn=0;nn!=leftn;++nn){
		PRTN[nn]+=1;
	}
	int thetd=0;
	int theno=0;
	for (int k=0;k!=K;++k){
		for (int b=0;b!=B;++b){	
			PVset[thetd].resize(theno+1,k);
			PBset[thetd].resize(theno+1,b);
			theno+=1;
			if (theno>=PRTN[thetd]){
				thetd+=1;
				theno=0;
			}
		}	
	}
	basen=floor(double(S)/double(TTRD));
	for (int nn=0;nn!=TTRD;++nn){
		PPRTN[nn]=basen;
	}
	leftn=S-basen*TTRD;
	for (int nn=0;nn!=leftn;++nn){
		PPRTN[nn]+=1;
	}
	thetd=0;
	theno=0;
	for (int s=0;s!=S;++s){
		PPSset[thetd].resize(theno+1,s);
		theno+=1;
		if (theno>=PPRTN[thetd]){
			thetd+=1;
			theno=0;
		}
	}	
}

void CGsetup(){
	for (int i=0;i!=I;++i){
		BDindset[i].resize(T);
		BDset[i].resize(T);
	}
	for (int i=0;i!=I;++i){
		for (int t=0;t!=T;++t){
			BDBN[i][t]=0;
		}
	}
	for (int b=0;b!=B;++b){
		for (int t=0;t!=T;++t){
			BTindex[b][t]=BTN;
			BTN+=1;
		}
	}
	for (int s=0;s!=S;++s){
		for (int t=ST[s][0];t<=ST[s][1];++t){
			TSdn[t]=0; 
		}
	}
	for (int s=0;s!=S;++s){
		for (int t=ST[s][0];t<=ST[s][1];++t){
			TSdn[t]+=1; 
			TSdex[t].resize(TSdn[t],s);
		}
	}
	for (int i=0;i!=I;++i){
		for (int t=E[i][0];t<=E[i][1];++t){
			OVIT[i][t]=1;
		}
	}    
	for (int i=K;i!=2*K;++i){
		for (int b=0;b!=B;++b){
			int timet=BRT[b]; 
			int edtime=HDT[b]; 
			if (HDT[b]!=-1){
				for (int tt=timet;tt<edtime;++tt){
					OVIT[i][tt]=0;}}
		}
	}
	for (int i=0;i!=K;++i){
		if (VLL[i]>=2){
			for (int b=0;b!=B;++b){
				int time02=Chaocu[b];
				if (time02!=-1){
					int timet=BRT[b];
					for (int t=timet;t<=time02-1;++t){
						OVIT[i][t]=0;
					}
				}
			}
		}
	}
	for (int i=0;i!=I;++i){
		for (int t=E[i][0];t<=E[i][1];++t){
			int doable=0;
			for (int n=0;n!=TSdn[t];++n){
				int thes=TSdex[t][n];
				if (BRK[thes][0]+D[I]<=t){
					doable=1;
					break;
				}
				if (t+D[i]<=BRK[thes][1]){
					doable=1;
					break;
				}
			}
			OVIT[i][t]=doable; 
		}
	}
	for (int n=0;n!=HWPN;++n){ 
		for (int t=0;t!=T;++t){
			HTindex[n][t]=HTN;
			HTN+=1;
		}
	}
	for (int n=0;n!=NCPN;++n){
		for (int t=0;t!=T;++t){
			GTindex[n][t]=GTN;
			GTN+=1;
		}
	}
	noncrodual.resize(GTN);
	hdwaydual.resize(HTN);
	berocudual.resize(BTN);
}

void inputData () { 
	PRLsetup();
	CGsetup();
	totallb=-LL;
	BDN=0;
	for (int ii=0;ii!=I;++ii){
		for (int tt=0;tt!=T;++tt){
			vector<int>().swap(BDindset[ii][tt]);
			vector<double>().swap(BDset[ii][tt]);
			BDBN[ii][tt]=0;
		}
	}
}

void Inicolload(IloModel model,IloNumVarArray x){ 
	IloEnv env = model.getEnv();
	IloInt s,i,j,t,k;   
	IloNumArray vescover(env, K);    
	IloNumArray berocu(env,BTN);    
	IloNumArray headway(env, HTN);
	IloNumArray noncro(env, GTN);    
	IloNumArray bencro(env, BDN);   
	IloNumArray encro(env, 1);     
	IloNumArray FIXcro(env, FIXN);    
	{  
		for (k=0;k!=K;++k){vescover[k]=0;}
		for (i=0;i!=BTN;++i){berocu[i]=0;}
		for (i=0;i!=HTN;++i){headway[i]=0;}
		for (i=0;i!=GTN;++i){noncro[i]=0;}
		for (i=0;i!=BDN;++i){bencro[i]=1;}
		encro[0]=1;
		for (i=0;i!=FIXN;++i){FIXcro[i]=0;}
		x.add(IloNumVar(Totalcost(1) + Vessel(vescover)+Berocu(berocu)+Hdway(headway)+Noncro(noncro)+Bendcon(bencro)+ENcon(encro)+FIXcon(FIXcro)));
	}
	for (j = 0; j < K; j++) {  
		for (k=0;k!=K;++k){vescover[k]=0;}
		for (i=0;i!=BTN;++i){berocu[i]=0;}
		for (i=0;i!=HTN;++i){headway[i]=0;}
		for (i=0;i!=GTN;++i){noncro[i]=0;}
		for (i=0;i!=BDN;++i){bencro[i]=0;}
		encro[0]=0;
		for (i=0;i!=FIXN;++i){FIXcro[i]=0;}
		vescover[j]=1;
		x.add(IloNumVar(Totalcost(C1[j]) + Vessel(vescover)+Berocu(berocu)+ Hdway(headway)+Noncro(noncro)+Bendcon(bencro)+ENcon(encro)+FIXcon(FIXcro)));
	}
	for (j = 0; j < FIXN; j++) { 
		int thecol=j; 
		for (k=0;k!=K;++k){vescover[k]=0;}
		for (i=0;i!=BTN;++i){berocu[i]=0;}
		for (i=0;i!=HTN;++i){headway[i]=0;}
		for (i=0;i!=GTN;++i){noncro[i]=0;}
		for (i=0;i!=BDN;++i){bencro[i]=0;}
		encro[0]=0;
		for (i=0;i!=FIXN;++i){FIXcro[i]=0;}
		FIXcro[j]=1;
		int theves=FIXcolves[thecol]; 
		vescover[theves]=1;
		int thet1=FIXcoltimes[0][thecol]; 
		int thet3=FIXcoltimes[2][thecol]; 
		for (int n=0;n!=HWPN;++n){
			int thei=Hset[0][n];
			int thej=Hset[1][n];
			if (theves==thei){
				int et1=thet1+F[theves][thej]-1;  
				if (et1>T-1){et1=T-1;}
				for (int t1=thet1;t1<=et1;++t1){
					int theind=HTindex[n][t1]; 
					headway[theind]=1;
				}
			}
			if (theves==thej){ 
				int theind=HTindex[n][thet1]; 
				headway[theind]=1;
			}
			if (theves+K==thei){ 
				int et3=thet3+F[theves+K][thej]-1; 
				if (et3>T-1){et3=T-1;}
				for (int t1=thet3;t1<=et3;++t1){
					int theind=HTindex[n][t1]; 
					headway[theind]=1;
				}
			}
			if (theves+K==thej){ 
				int theind=HTindex[n][thet3]; 
				headway[theind]=1;
			}
		}
		for (int n=0;n!=NCPN;++n){
			int thei=ODS[0][n];
			int thej=ODS[1][n];
			if (theves==thei || theves==thej){ 
				int et01=thet1+D[theves]-1;  
				if (et01>T-1){et01=T-1;}
				for (int t1=thet1;t1<=et01;++t1){
					int theind=GTindex[n][t1];
					noncro[theind]=1;
				}			 
			}
			if (theves+K==thei || theves+K==thej){ 
				int et03=thet3+D[theves+K]-1;  
				if (et03>T-1){et03=T-1;}
				for (int t1=thet3;t1<=et03;++t1){
					int theind=GTindex[n][t1];
					noncro[theind]=1;
				}			 
			}
		}
		int theber=FIXcolberth[thecol];
		int thet2=FIXcoltimes[1][thecol];
		int et2=thet3-1; 
		for (int t1=thet2;t1<=et2;++t1){
			int theind=BTindex[theber][t1];
			berocu[theind]=1;
		}
		for (int nn=0;nn!=BDBN[theves][thet1];++nn){
			int thebn=BDindset[theves][thet1][nn];
			double thecof=BDset[theves][thet1][nn];
			bencro[thebn]-=thecof;

		}
		for (int nn=0;nn!=BDBN[theves+K][thet3];++nn){
			int thebn=BDindset[theves+K][thet3][nn];
			double thecof=BDset[theves+K][thet3][nn];
			bencro[thebn]-=thecof;
		}
		double thecost=FIXcolcost[thecol];
		x.add(IloNumVar(Totalcost(thecost)+Vessel(vescover)+Berocu(berocu)+Hdway(headway)+Noncro(noncro)+Bendcon(bencro)+ENcon(encro)+FIXcon(FIXcro))); 
	}
	N=0;
	NN=N; 
	TON=0; 
	vector<int>().swap(colves);
	vector<int>().swap(colberth);
	vector<double>().swap(colcost);
	for (int nn=0;nn!=3;++nn){ 
		vector<int>().swap(coltimes[nn]);
	}
	vescover.end();
	berocu.end();
	headway.end();
	noncro.end();
	bencro.end();
	encro.end();
	FIXcro.end();
}

double masterproblem (IloModel model,IloCplex lpsolver,IloNumVarArray x,int numsc) {
	double MVAL;
	IloEnv env = model.getEnv();
	IloInt j,k,i,t1;   
	IloNumArray vescover(env, K);     
	IloNumArray berocu(env,BTN);    
	IloNumArray headway(env, HTN);
	IloNumArray noncro(env, GTN);   
	IloNumArray bencro(env, BDN);  
	IloNumArray encro(env, 1);   
	IloNumArray FIXcro(env, FIXN);  
	try{
		for (j = N; j < numsc; j++) {  
			int thecol=j; 
			for (k=0;k!=K;++k){vescover[k]=0;}
			for (i=0;i!=BTN;++i){berocu[i]=0;}
			for (i=0;i!=HTN;++i){headway[i]=0;}
			for (i=0;i!=GTN;++i){noncro[i]=0;}
			for (i=0;i!=BDN;++i){bencro[i]=0;}
			encro[0]=0;
			for (i=0;i!=FIXN;++i){FIXcro[i]=0;}
			int theves=colves[thecol]; 
			vescover[theves]=1;
			int thet1=coltimes[0][thecol]; 
			int thet3=coltimes[2][thecol];
			for (int n=0;n!=HWPN;++n){
				int thei=Hset[0][n];
				int thej=Hset[1][n];
				if (theves==thei){
					int et1=thet1+F[theves][thej]-1;  
					if (et1>T-1){et1=T-1;}
					for (t1=thet1;t1<=et1;++t1){
						int theind=HTindex[n][t1]; 
						headway[theind]=1;
					}
				}
				if (theves==thej){ 
					int theind=HTindex[n][thet1]; 
					headway[theind]=1;
				}
				if (theves+K==thei){
					int et3=thet3+F[theves+K][thej]-1; 
					if (et3>T-1){et3=T-1;}
					for (t1=thet3;t1<=et3;++t1){
						int theind=HTindex[n][t1]; 
						headway[theind]=1;
					}
				}
				if (theves+K==thej){ 
					int theind=HTindex[n][thet3]; 
					headway[theind]=1;
				}
			}
			for (int n=0;n!=NCPN;++n){
				int thei=ODS[0][n];
				int thej=ODS[1][n];
				if (theves==thei || theves==thej){ 
					int et01=thet1+D[theves]-1;
					if (et01>T-1){et01=T-1;}
					for (t1=thet1;t1<=et01;++t1){
						int theind=GTindex[n][t1];
						noncro[theind]=1;
					}			 
				}
				if (theves+K==thei || theves+K==thej){
					int et03=thet3+D[theves+K]-1; 
					if (et03>T-1){et03=T-1;}
					for (t1=thet3;t1<=et03;++t1){
						int theind=GTindex[n][t1];
						noncro[theind]=1;
					}			 
				}
			}
			int theber=colberth[thecol];
			int thet2=coltimes[1][thecol];
			int et2=thet3-1; 
			for (t1=thet2;t1<=et2;++t1){
				int theind=BTindex[theber][t1];
				berocu[theind]=1;
			}
			for (int nn=0;nn!=BDBN[theves][thet1];++nn){
				int thebn=BDindset[theves][thet1][nn];
				double thecof=BDset[theves][thet1][nn];
				bencro[thebn]-=thecof;

			}
			for (int nn=0;nn!=BDBN[theves+K][thet3];++nn){
				int thebn=BDindset[theves+K][thet3][nn];
				double thecof=BDset[theves+K][thet3][nn];
				bencro[thebn]-=thecof;
			}
			double thecost=colcost[thecol];
			x.add(IloNumVar(Totalcost(colcost[thecol])+Vessel(vescover)+Berocu(berocu)+Hdway(headway)+Noncro(noncro)+Bendcon(bencro)+ENcon(encro)+FIXcon(FIXcro))); 
		}
		{
			lpsolver.solve();
			if(lpsolver.getStatus() ==IloAlgorithm::Optimal){
				vector<double>().swap(bdsdual);
				bdsdual.resize(BDN);
				for (i = 0; i < K; i++) {
					vesdual[i] = lpsolver.getDual(Vessel[i]);
				}
				for (i=0;i<BTN; i++){
					berocudual[i]=lpsolver.getDual(Berocu[i]);
				}
				for (i = 0; i < HTN; i++) {
					hdwaydual[i] = lpsolver.getDual(Hdway[i]);
				}
				for (i=0;i<GTN; i++){
					noncrodual[i]=lpsolver.getDual(Noncro[i]);
				}
				for (i=0;i<BDN; i++){
					bdsdual[i]=lpsolver.getDual(Bendcon[i]);
				}
			}
			MVAL=lpsolver.getObjValue();
		}
	}
	catch(IloException& ex){
		cerr << ex << endl;
	}
	catch(...){
		cerr << "Error..." << endl;
	}
	N=NN; 
	vescover.end();
	headway.end();
	noncro.end();
	berocu.end();
	bencro.end();
	encro.end();
	FIXcro.end();
	return MVAL;
}

void pathgen(int thev, int berth, int thread){ 
	double acpbd=-0.0001;
	int CA[2]; 
	int CB[2];  
	double basecost=0; 
	basecost+=C3[thev][berth]; 
	basecost-=vesdual[thev];
	CA[0]=E[thev][0];
	CA[1]=E[thev][1];
	if (CA[0]<BRT[berth]-D[thev]){ 
		CA[0]=BRT[berth]-D[thev];
	}
	CB[0]=E[thev+K][0];
	CB[1]=E[thev+K][1];
	if (CB[0]<CA[0]+D[thev]+H[thev][berth]){
		CB[0]=CA[0]+D[thev]+H[thev][berth];
	}
	if (CA[1]>CB[1]-D[thev+K]-H[thev][berth]){
		CA[1]=CB[1]-D[thev+K]-H[thev][berth];
	}
	int flt1=-1; 
	int flt2=-1; 
	int fls1=-1; 
	int flt3=-1; 
	int fls3=-1;
	double flcost=LL; 
	for (int t=CA[0];t<=CA[1];++t){
		if (OVIT[thev][t]==0){
			continue;
		}
		int tt1=t;
		int tt2=t+D[thev];
		double trc=basecost; 
		trc+=C2[thev][tt1];
		for (int gg=0;gg!=HWPN;++gg){
			int thei=Hset[0][gg];
			int thej=Hset[1][gg];
			if (thev==thei){ 
				int et1=tt1+F[thev][thej]-1;
				if (et1>T-1){et1=T-1;}
				for (int t1=tt1;t1<=et1;++t1){
					int theind=HTindex[gg][t1]; 
					trc-=hdwaydual[theind];
				}
			}
			if (thev==thej){ 
				int theind=HTindex[gg][tt1];
				trc-=hdwaydual[theind];
			}
		}
		for (int gg=0;gg!=NCPN;++gg){
			int thei=ODS[0][gg];
			int thej=ODS[1][gg];
			if (thev==thei || thev==thej){
				int etgg1=tt1+D[thev]-1;
				if (etgg1>T-1){
					etgg1=T-1;
				}
				for (int hh=tt1;hh<=etgg1;++hh){
					int theind=GTindex[gg][hh];
					trc-=noncrodual[theind];
				}		 
			}
		}
		for (int nn=0;nn!=BDBN[thev][tt1];++nn){
			int thebd=BDindset[thev][tt1][nn];
			double thecof=BDset[thev][tt1][nn];
			trc+=bdsdual[thebd]*thecof;}
		double ftrc=trc;
		int eet3=tt2+H[thev][berth]; 
		for (int t3=eet3;t3<=CB[1];++t3){ 
			if (OVIT[thev+K][t3]==0){
				continue;}
			trc=ftrc;
			int tt3=t3;
			trc+=C2[thev+K][tt3]; 
			for (int hh=tt2;hh<tt3;++hh){
				int theind=BTindex[berth][hh];
				trc-=berocudual[theind];
			}
			for (int gg=0;gg!=HWPN;++gg){
				int thei=Hset[0][gg];
				int thej=Hset[1][gg];
				if (thev+K==thei){ 
					int et3=tt3+F[thev+K][thej]-1;
					if (et3>T-1){et3=T-1;}
					for (int t1=tt3;t1<=et3;++t1){
						int theind=HTindex[gg][t1]; 
						trc-=hdwaydual[theind];
					}
				}
				if (thev+K==thej){ 
					int theind=HTindex[gg][tt3];
					trc-=hdwaydual[theind];
				}
			}
			for (int gg=0;gg!=NCPN;++gg){
				int thei=ODS[0][gg];
				int thej=ODS[1][gg];
				if (thev+K==thei || thev+K==thej){
					int etgg3=tt3+D[thev+K]-1;
					if (etgg3>T-1){
						etgg3=T-1;
					}
					for (int hh=tt3;hh<=etgg3;++hh){
						int theind=GTindex[gg][hh];
						trc-=noncrodual[theind];
					}		 
				}
			}
			for (int nn=0;nn!=BDBN[thev+K][tt3];++nn){
				int thebd=BDindset[thev+K][tt3][nn];
				double thecof=BDset[thev+K][tt3][nn];
				trc+=bdsdual[thebd]*thecof;}
			if (trc<flcost){
				flcost=trc;
				flt1=tt1;
				flt2=tt2;
				flt3=tt3;
			}
		}
	}
	if (flcost<acpbd){
		NCOLN[thread]+=1;
		prcolves[thread].resize(NCOLN[thread],thev);
		prcolberth[thread].resize(NCOLN[thread],berth);
		prcoltimes[thread][0].resize(NCOLN[thread],flt1);
		prcoltimes[thread][1].resize(NCOLN[thread],flt2);
		prcoltimes[thread][2].resize(NCOLN[thread],flt3);
		double comcost=0;
		comcost+=C2[thev][flt1]+C2[thev+K][flt3]+C3[thev][berth];
		prcolcost[thread].resize(NCOLN[thread],comcost);
	}
}

int colgen(){
	int newcol=0;	
	for (int nn=0;nn!=TTRD;++nn){
		NCOLN[nn]=0;
		vector<int>().swap(prcolves[nn]);
		vector<int>().swap(prcolberth[nn]);
		vector<double>().swap(prcolcost[nn]);
		for (int mm=0;mm!=3;++mm){
			vector<int>().swap(prcoltimes[nn][mm]);
		}
	} 
#pragma omp parallel sections num_threads(6)
	{
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[0];++mm){
				int k=PVset[0][mm];
				int b=PBset[0][mm];
				pathgen(k,b,0);
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[1];++mm){
				int k=PVset[1][mm];
				int b=PBset[1][mm];
				pathgen(k,b,1);
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[2];++mm){
				int k=PVset[2][mm];
				int b=PBset[2][mm];
				pathgen(k,b,2);
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[3];++mm){
				int k=PVset[3][mm];
				int b=PBset[3][mm];
				pathgen(k,b,3);
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[4];++mm){
				int k=PVset[4][mm];
				int b=PBset[4][mm];
				pathgen(k,b,4);
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[5];++mm){
				int k=PVset[5][mm];
				int b=PBset[5][mm];
				pathgen(k,b,5);
			}
		}									
	}
	for (int thread=0;thread!=TTRD;++thread){
		newcol+=NCOLN[thread];
		for (int mm=0;mm!=NCOLN[thread];++mm){
			NN+=1;
			TON+=1;
			int thev=prcolves[thread][mm];
			colves.resize(TON,thev);
			int berth=prcolberth[thread][mm];
			colberth.resize(TON,berth);
			int tt1=prcoltimes[thread][0][mm];
			coltimes[0].resize(TON,tt1);
			int tt2=prcoltimes[thread][1][mm];
			coltimes[1].resize(TON,tt2);
			int tt3=prcoltimes[thread][2][mm];
			coltimes[2].resize(TON,tt3);
			double thecost=prcolcost[thread][mm];
			colcost.resize(TON,thecost);
		}
	} 
	return newcol;
}

void PCGsetup(int create){
	if (create==1){
		ITN=0;
		for (int k=0;k!=K;++k){
			for (int n=0;n!=nt1used[k]; ++n){
				int thet=usedt1[k][n];
				Iset[ITN]=k;
				Tset[ITN]=thet;
				ITN+=1;
			}
		}
		for (int k=0;k!=K;++k){
			for (int n=0;n!=nt3used[k]; ++n){
				int thet=usedt3[k][n];
				Iset[ITN]=k+K;
				Tset[ITN]=thet;
				ITN+=1;
			}
		}
	}
	InsertionSort(Tset,Iset,ITN); 
	if (create==1){
		vector<double>().swap(ITres);
		ITres.resize(ITN); 
		for (int nn=0;nn!=ITN;++nn){
			int thei=Iset[nn];
			int thet=Tset[nn];
			if (thei<K){
				ITres[nn]=T1result[thei][thet];}
			else {
				ITres[nn]=T3result[thei-K][thet];
			}
		}
	}
	vector<double>().swap(ptaskdual);
	ptaskdual.resize(ITN);
}

void Pshrink(){
	for (int s=0;s!=S;++s){
		SITN[s]=0;
	}
	for (int s=0;s!=S;++s){
		vector<int>().swap(SIS[s]);
	}
	for (int n=0;n!=ITN;++n){
		int thei=Iset[n];
		int thet=Tset[n];
		for (int m=0;m!=TSdn[thet];++m){
			int thes=TSdex[thet][m];
			SITN[thes]+=1;
			SIS[thes].resize(SITN[thes],n);
		}
	}
}

void PinputData (int create) {
	PCGsetup(create);
	Pshrink();
	vector<int>().swap(pcolshift);	
	vector<double>().swap(pcolcost);	
	vector<int>().swap(pcollen);	
	for (int nn=0;nn!=PTON;++nn){
		vector<int>().swap(pcoltasks[nn]);}
	PTON=0; 
}

void PInicolload(IloModel model,IloNumVarArray x){ 
	IloEnv env = model.getEnv(); 
	IloInt j,k;  
	IloNumArray taskcover(env, ITN);   
	IloNumArray FIXcover(env, PFIXN); 
	for (j = 0; j < ITN; j++) { 
		for (k=0;k!=ITN;++k){taskcover[k]=0;}
		for (k=0;k!=PFIXN;++k){FIXcover[k]=0;}
		taskcover[j]=1;
		double thecost=10000;
		x.add(IloNumVar(PTotalcost(thecost) + PTask(taskcover)+PTask02(taskcover)+PFIXcon(FIXcover)));
	}
	for (j = 0; j < PFIXN; j++) {
		for (k=0;k!=ITN;++k){taskcover[k]=0;}
		for (k=0;k!=PFIXN;++k){FIXcover[k]=0;}
		int thecol=j;
		FIXcover[j]=1;
		int thelen=FIXpcollen[thecol];
		for (int nn=0;nn!=thelen;++nn){
			int thect=FIXpcoltasks[thecol][nn];
			if (thect!=-1){
				taskcover[thect]=1;
			} 
		}
		double thecost=FIXpcolcost[thecol];
		x.add(IloNumVar(PTotalcost(thecost)+PTask(taskcover)+PTask02(taskcover)+PFIXcon(FIXcover))); 
	}
	PN=0;
	PNN=PN;
}

double pmasterproblem (IloModel model,IloCplex lpsolver,IloNumVarArray x,int numsc) {
	IloEnv env = model.getEnv(); 
	double MVAL;
	double optvalue;
	IloInt j,k; 
	IloNumArray taskcover(env, ITN); 
	IloNumArray FIXcover(env, PFIXN);
	try{
		for (j = PN; j < numsc; j++) {
			for (k=0;k!=ITN;++k){taskcover[k]=0;}
			for (k=0;k!=PFIXN;++k){FIXcover[k]=0;}
			int thecol=j;
			int thelen=pcollen[thecol];
			for (int nn=0;nn!=thelen;++nn){
				int thect=pcoltasks[thecol][nn];
				if (thect!=-1){ 
					taskcover[thect]=1;
				} 
			}
			double thecost=pcolcost[thecol];
			x.add(IloNumVar(PTotalcost(pcolcost[thecol])+PTask(taskcover)+PTask02(taskcover)+PFIXcon(FIXcover))); 
		}
		{
			lpsolver.solve();
			optvalue=PLL;
			if(lpsolver.getStatus() ==IloAlgorithm::Optimal){
				optvalue=lpsolver.getObjValue();
				for (int gg=0;gg<ITN; ++gg){
					ptaskdual[gg]=lpsolver.getDual(PTask[gg])+lpsolver.getDual(PTask02[gg]);
				}
			}
			MVAL=lpsolver.getObjValue();
		}
	}
	catch(IloException& ex){
		cerr << ex << endl;
	}
	catch(...){
		cerr << "Error..." << endl;
	}
	PN=PNN;
	return MVAL;
}

void ppathgen(int shift, int thread){ 
	double acpbd=-0.0001;
	double basecost=0;
	basecost+=C4[shift];
	int tfln=0; 
	vector<int> ftset; 
	vector<double> flcost (ITN); 
	vector<int> fllen(ITN); 
	vector<vector<int>> flind(ITN);
	int LRT=BRK[shift][1]; 
	for (int nn=0;nn!=SITN[shift];++nn){
		int theind=SIS[shift][nn]; 
		int thei=Iset[theind];
		int thet=Tset[theind];
		if (thet+D[thei]<=LRT){
			tfln+=1;
			ftset.resize(tfln,theind);
			fllen[theind]=1;
			flind[theind].resize(1,theind);
			flcost[theind]=-ptaskdual[theind];
		}
		else {
			break;
		}
	}
	for (int ln=0;ln<tfln-1;++ln){
		int lind=ftset[ln];
		int ltask=Iset[lind];
		int ltime=Tset[lind];;
		int llen=fllen[lind];
		double lcost=flcost[lind];
		for (int fn=ln+1;fn<tfln;++fn){ 
			int find=ftset[fn]; 
			int ftask=Iset[find];
			int ftime=Tset[find];
			if (ltask!=ftask&&ltime+D[ltask]+Q[ltask][ftask]<=ftime){ 
				if (lcost-ptaskdual[find]<flcost[find]){ 
					flcost[find]=lcost-ptaskdual[find];
					int flen=llen+1;
					fllen[find]=flen;
					vector<int>().swap(flind[find]);
					for (int nn=0;nn!=llen;++nn){
						int temp=flind[lind][nn];
						flind[find].resize(nn+1,temp);
					}
					flind[find].resize(flen,find);
				}
			}
		}
	}
	int tbln=0; 
	vector<int> btset;
	vector<double> blcost (ITN);
	vector<int> bllen(ITN); 
	vector<vector<int>> blind(ITN); 
	int ERT=BRK[shift][0]; 
	for (int nn=0;nn!=SITN[shift];++nn){
		int theind=SIS[shift][nn]; 
		int thei=Iset[theind];
		int thet=Tset[theind];
		int thetime=thet; 
		if (thetime<ERT+D[I]){
			continue; 
		}
		tbln+=1;
		btset.resize(tbln,theind);
		bllen[theind]=1;
		blind[theind].resize(1,theind);
		blcost[theind]=-ptaskdual[theind];
	}
	for (int fn=tbln-1;fn>=1;--fn){  
		int find=btset[fn]; 
		int ftask=Iset[find];
		int ftime=Tset[find];
		int flen=bllen[find];
		double fcost=blcost[find];
		for (int ln=fn-1;ln>=0;--ln){ 
			int lind=btset[ln];
			int ltask=Iset[lind];
			int ltime=Tset[lind];
			if (ltask!=ftask&&ltime+D[ltask]+Q[ltask][ftask]<=ftime){ 
				if (fcost-ptaskdual[lind]<blcost[lind]){ 
					blcost[lind]=fcost-ptaskdual[lind];
					int llen=flen+1;
					bllen[lind]=llen; 
					vector<int>().swap(blind[lind]);
					blind[lind].resize(1,lind);
					for (int nn=1;nn<llen;++nn){
						int temp=blind[find][nn-1];
						blind[lind].resize(nn+1,temp);
					}
				}
			}
		}
	}
	int seft=-1; 
	int sebt=-1; 
	double theminival=acpbd;
	for (int ln=0;ln!=tfln;++ln){
		int thelind=ftset[ln];
		int thelt=Iset[thelind];
		double tempcost=basecost+flcost[thelind];
		if (theminival>tempcost){
			seft=thelind; 
			theminival=tempcost;
			sebt=-1;
		}
	}
	for (int fn=0;fn!=tbln;++fn){
		int thefind=btset[fn];
		int thebt=Iset[thefind];
		double tempcost=basecost+blcost[thefind];
		if (theminival>tempcost){
			seft=-1;
			sebt=thefind; 
			theminival=tempcost;
		}
	}
	for (int ln=0;ln!=tfln;++ln){
		int thelind=ftset[ln];
		int thelt=Iset[thelind];
		int theltime=Tset[thelind];
		int lrstime=theltime+D[thelt]; 
		int ltime=theltime; 
		if (lrstime<BRK[shift][0]){
			lrstime=BRK[shift][0];
		}
		for (int fn=0;fn!=tbln;++fn){
			int thebind=btset[fn];
			int thebt=Iset[thebind];
			int theftime=Tset[thebind];
			int brstime=theftime-D[I]; 
			if (brstime>BRK[shift][1]){
				brstime=BRK[shift][1];
			}
			if (lrstime>brstime){ 
				continue;
			}
			int ftime=theftime;
			if (thelt!=thebt&&ltime+D[thelt]+Q[thelt][thebt]<=ftime){ 
				double tempcost=basecost+flcost[thelind]+blcost[thebind];
				if (theminival>tempcost){
					theminival=tempcost;
					seft=thelind;
					sebt=thebind;
				}
			}
		}
	}
	if (theminival<acpbd){ 
		NCOLN[thread]+=1;
		prpcolshift[thread].resize(NCOLN[thread],shift);
		prpcoltasks[thread].resize(NCOLN[thread]);
		int templen=0;
		if (seft!=-1){
			for (int nn=0;nn!=fllen[seft];++nn){
				templen+=1;
				int tempind=flind[seft][nn];
				prpcoltasks[thread][NCOLN[thread]-1].resize(templen,tempind);
			}
		}
		templen+=1;
		prpcoltasks[thread][NCOLN[thread]-1].resize(templen,-1); 
		if (sebt!=-1){
			for (int nn=0;nn!=bllen[sebt];++nn){
				templen+=1;
				int tempind=blind[sebt][nn];
				prpcoltasks[thread][NCOLN[thread]-1].resize(templen,tempind);
			}
		}
		prpcollen[thread].resize(NCOLN[thread],templen);
		prpcolcost[thread].resize(NCOLN[thread],basecost);
	}
}

int pcolgen(){ 
	int newcol=0;	
	for (int nn=0;nn!=TTRD;++nn){
		vector<int>().swap(prpcolshift[nn]);
		vector<double>().swap(prpcolcost[nn]);
		for (int mm=0;mm!=NCOLN[nn];++mm){
			vector<int>().swap(prpcoltasks[nn][mm]);
		}
		vector<int>().swap(prpcollen[nn]);
		NCOLN[nn]=0;
	} 
#pragma omp parallel sections num_threads(6)
	{
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[0];++mm){
				int s=PPSset[0][mm];
				if (SITN[s]>0){
					ppathgen(s,0);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[1];++mm){
				int s=PPSset[1][mm];
				if (SITN[s]>0){
					ppathgen(s,1);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[2];++mm){
				int s=PPSset[2][mm];
				if (SITN[s]>0){
					ppathgen(s,2);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[3];++mm){
				int s=PPSset[3][mm];
				if (SITN[s]>0){
					ppathgen(s,3);}
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[4];++mm){
				int s=PPSset[4][mm];
				if (SITN[s]>0){
					ppathgen(s,4);}	
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[5];++mm){
				int s=PPSset[5][mm];
				if (SITN[s]>0){
					ppathgen(s,5);}
			}
		}									
	}
	for (int thread=0;thread!=TTRD;++thread){
		newcol+=NCOLN[thread];
		for (int mm=0;mm!=NCOLN[thread];++mm){
			PNN+=1; 
			PTON+=1;
			int shift=prpcolshift[thread][mm];
			pcolshift.resize(PTON,shift);
			double basecost=prpcolcost[thread][mm];
			pcolcost.resize(PTON,basecost);
			int templen=prpcollen[thread][mm];
			pcollen.resize(PTON,templen);
			pcoltasks.resize(PTON);
			for (int tt=0;tt!=templen;++tt){
				int theind= prpcoltasks[thread][mm][tt];
				pcoltasks[PTON-1].resize(tt+1,theind);
			}
		}
	} 
	return newcol;
}

double pmastersolver(int create){ 
	PinputData (create);
	IloEnv env;     
	IloModel msmodel(env);
	IloCplex lpsolver(msmodel);
	lpsolver.setOut(env.getNullStream());
	lpsolver.setParam(IloCplex::Threads, 1);  
	IloNumVarArray x(env);  
	IloInt i;    
	PTotalcost = IloAdd(msmodel, IloMinimize(env));
	IloNumArray taskreach(env, ITN); 
	for (i=0;i!=ITN;++i){taskreach[i]=ITres[i];}  
	PTask = IloAdd(msmodel, IloRangeArray(env, taskreach, IloInfinity));  
	PTask02 = IloAdd(msmodel, IloRangeArray(env, -IloInfinity, taskreach));  
	IloNumArray PFIXreach(env, PFIXN);  
	for (i=0;i!=PFIXN;++i){PFIXreach[i]=1;} 
	PFIXcon=IloAdd(msmodel, IloRangeArray(env, PFIXreach,IloInfinity));  
	PInicolload(msmodel,x);
	double lwbd;
	lwbd=pmasterproblem(msmodel,lpsolver,x,PNN); 
	int ncs=pcolgen();
	while (ncs>0){
		lwbd=pmasterproblem(msmodel,lpsolver,x,PNN);
		ncs=pcolgen();
	}
	Pintsol=1;
	for (IloInt j = 0; j <PNN; j++) {  
		double trv=lpsolver.getValue(x[j+ITN+PFIXN]);		
		if (trv>0.0001){
			if (trv<0.99){Pintsol=0;}  
			int h=int(j);
		}
	}
	env.end();
	return lwbd;
}

double mastersolver( ){ 
	double lwbd;
	double lwpsc;
	double uppsc;
	double thegap;
	int feasi=0;
	while (feasi==0){
		feasi=1; 
		IloEnv env;     
		IloModel msmodel(env);
		IloCplex lpsolver(msmodel);
		lpsolver.setOut(env.getNullStream());
		lpsolver.setParam(IloCplex::Threads, 1);  
		IloNumVarArray x(env);  
		IloInt i; 
		Totalcost = IloAdd(msmodel, IloMinimize(env));
		IloNumArray vesreach(env, K); 
		for (i=0;i!=K;++i){vesreach[i]=1;}  
		Vessel = IloAdd(msmodel, IloRangeArray(env, vesreach, IloInfinity));  
		IloNumArray flheadway(env, HTN); 
		for (i=0;i!=HTN;++i){flheadway[i]=1;} 
		Hdway= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, flheadway)); 
		IloNumArray bicross(env, GTN);
		for (i=0;i!=GTN;++i){bicross[i]=1;}
		Noncro= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, bicross)); 
		IloNumArray berthtime(env, BTN); 
		for (i=0;i!=BTN;++i){berthtime[i]=1;}
		Berocu= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, berthtime));
		IloNumArray bendocu(env, BDN); 
		for (i=0;i!=BDN;++i){bendocu[i]=0;}
		Bendcon= IloAdd(msmodel, IloRangeArray(env, bendocu, IloInfinity)); 
		IloNumArray enocu(env, 1); 
		enocu[0]=0;
		ENcon=IloAdd(msmodel, IloRangeArray(env, enocu, IloInfinity)); 
		IloNumArray fixocu(env, FIXN); 
		for (i=0;i!=FIXN;++i){fixocu[i]=1;} 
		FIXcon=IloAdd(msmodel, IloRangeArray(env, fixocu, IloInfinity)); 
		Inicolload(msmodel,x);
		lwbd=masterproblem(msmodel,lpsolver,x,NN); 
		int ncs=colgen();
		while (ncs>0){
			lwbd=masterproblem(msmodel,lpsolver,x,NN);
			ncs=colgen();
		}
		lwbd=ceil(lwbd-0.01);
		for (int k=0;k!=K;++k){
			nt1used[k]=0;
			vector<int>().swap(usedt1[k]);
			nt3used[k]=0;
			vector<int>().swap(usedt3[k]);
		}
		for (int k1=0;k1!=K;++k1){
			for (int t1=0;t1!=T;++t1){
				T1result[k1][t1]=0;
				T3result[k1][t1]=0;
			}
		}
		mintsol=1;
		for (IloInt j = 0; j <NN; j++) {
			double trv=lpsolver.getValue(x[j+1+FIXN+K]);
			if (trv>0.001){
				if (trv<0.99){
					mintsol=0;
				}
				int h=j; 
				int theves=colves[h]; 
				int theber=colberth[h]; 
				int tt1=coltimes[0][h];
				int tt3=coltimes[2][h];
				if (T1result[theves][tt1]==0){
					nt1used[theves]+=1;
					usedt1[theves].resize(nt1used[theves],tt1);
					if (nt1used[theves]>1.01){mintsol=0;}  
				}
				T1result[theves][tt1]+=trv;
				if (T3result[theves][tt3]==0){
					nt3used[theves]+=1;
					usedt3[theves].resize(nt3used[theves],tt3);
					if (nt3used[theves]>1.01){mintsol=0;}
				}
				T3result[theves][tt3]+=trv;
			}
		}
		lwpsc=lpsolver.getValue(x[0]); 
		uppsc=pmastersolver(1);
		thegap=100*(uppsc-lwpsc)/double(lwbd);
		if (thegap>0.01){
			feasi=0; 
			for (int nn=0;nn!=ITN;++nn){
				int thei=Iset[nn];
				int thet=Tset[nn];
				double thedual=ptaskdual[nn];
				BDBN[thei][thet]+=1;
				BDindset[thei][thet].resize(BDBN[thei][thet],BDN);
				BDset[thei][thet].resize(BDBN[thei][thet],thedual);
			}
			BDN+=1; 
			TBDN+=1;  
		}
		env.end();
		t_crt=clock();
		if (t_crt-t_start>=uptime*1000){
			cout<<"Time limit reached"<<endl;
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			break;
		}
	}
	if (mintsol==1){
		Vescost=lwbd-lwpsc;
		cout<<"a new vescost is found by branching in the first stage"<<Vescost<<endl;
	}
	if (mintsol==1 && Pintsol==1){ 
		PLcost=uppsc;
		cout<<"a new upper bound is found by branching in the first stage"<<endl;	
	}
	return lwbd;
}

double secondphase( ){ 
	int feasi=0;
	double lwbd;
	double lwpsc;
	double uppsc;
	double thegap;
	mintsol=1;  
	while (feasi==0){
		feasi=1;
		IloEnv env;   
		IloModel msmodel(env);
		IloCplex lpsolver(msmodel);
		lpsolver.setOut(env.getNullStream());
		lpsolver.setParam(IloCplex::Threads, 1);  
		IloNumVarArray x(env); 
		IloInt i; 
		Totalcost = IloAdd(msmodel, IloMinimize(env));
		IloNumArray vesreach(env, K); 
		for (i=0;i!=K;++i){vesreach[i]=1;}
		Vessel = IloAdd(msmodel, IloRangeArray(env, vesreach, IloInfinity));
		IloNumArray flheadway(env, HTN); 
		for (i=0;i!=HTN;++i){flheadway[i]=1;} 
		Hdway= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, flheadway));
		IloNumArray bicross(env, GTN); 
		for (i=0;i!=GTN;++i){bicross[i]=1;}
		Noncro= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, bicross));
		IloNumArray berthtime(env, BTN);
		for (i=0;i!=BTN;++i){berthtime[i]=1;} 
		Berocu= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, berthtime));  
		IloNumArray bendocu(env, BDN); 
		for (i=0;i!=BDN;++i){bendocu[i]=0;} 
		Bendcon= IloAdd(msmodel, IloRangeArray(env, bendocu, IloInfinity));  
		IloNumArray enocu(env, 1);  
		enocu[0]=0;
		ENcon=IloAdd(msmodel, IloRangeArray(env, enocu, IloInfinity)); 
		IloNumArray fixocu(env, FIXN); 
		for (i=0;i!=FIXN;++i){fixocu[i]=1;}
		FIXcon=IloAdd(msmodel, IloRangeArray(env, fixocu, IloInfinity));
		Inicolload(msmodel,x);
		lwbd=masterproblem(msmodel,lpsolver,x,NN);
		int ncs=colgen();
		while (ncs>0){
			lwbd=masterproblem(msmodel,lpsolver,x,NN);
			ncs=colgen( );
		}
		lwbd=ceil(lwbd-0.01);
		mintsol=1;
		for (IloInt j = 0; j <NN; j++) {
			double trv=lpsolver.getValue(x[j+1+FIXN+K]);
			if (trv>0.001){
				if (trv<0.99){
					mintsol=0;
				}
			}}
		lwpsc=lpsolver.getValue(x[0]); 
		t_crt=clock();
		if (t_crt-t_start>=uptime*1000){
			cout<<"Time limit reached"<<endl;
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			break;
		}
		if (mintsol==1){
			Vescost=lwbd-lwpsc;
			for (int k=0;k!=K;++k){
				nt1used[k]=0;
				vector<int>().swap(usedt1[k]);
				nt3used[k]=0;
				vector<int>().swap(usedt3[k]);
			}
			for (int k1=0;k1!=K;++k1){
				for (int t1=0;t1!=T;++t1){
					T1result[k1][t1]=0;
					T3result[k1][t1]=0;
				}
			}
			for (IloInt j = 0; j <FIXN; j++) {
				double trv=lpsolver.getValue(x[j+1+K]);
				if (trv>0.001){
					int h=j;
					int theves=FIXcolves[h]; 
					int theber=FIXcolberth[h];
					int tt1=FIXcoltimes[0][h];
					int tt3=FIXcoltimes[2][h];				
					if (T1result[theves][tt1]==0){
						nt1used[theves]+=1;
						usedt1[theves].resize(nt1used[theves],tt1);
						if (nt1used[theves]>1.01){mintsol=0;} 
					}
					T1result[theves][tt1]+=trv;
					if (T3result[theves][tt3]==0){
						nt3used[theves]+=1;
						usedt3[theves].resize(nt3used[theves],tt3);
						if (nt3used[theves]>1.01){mintsol=0;} 
					}
					T3result[theves][tt3]+=trv;
				}
			}
			for (IloInt j = 0; j <NN; j++) {
				double trv=lpsolver.getValue(x[j+1+FIXN+K]);	
				if (trv>0.001){
					int h=j;
					int theves=colves[h];
					int theber=colberth[h]; 
					int tt1=coltimes[0][h];
					int tt3=coltimes[2][h];				
					if (T1result[theves][tt1]==0){
						nt1used[theves]+=1;
						usedt1[theves].resize(nt1used[theves],tt1);
						if (nt1used[theves]>1.01){mintsol=0;} 
					}
					T1result[theves][tt1]+=trv;
					if (T3result[theves][tt3]==0){
						nt3used[theves]+=1;
						usedt3[theves].resize(nt3used[theves],tt3);
						if (nt3used[theves]>1.01){mintsol=0;}
					}
					T3result[theves][tt3]+=trv;
				}
			}
			uppsc=pmastersolver(1);
			thegap=100*(uppsc-lwpsc)/double(lwbd);
			if (thegap>0.01){
				feasi=0;
				for (int nn=0;nn!=ITN;++nn){
					int thei=Iset[nn];
					int thet=Tset[nn];
					double thedual=ptaskdual[nn];
					BDBN[thei][thet]+=1;
					BDindset[thei][thet].resize(BDBN[thei][thet],BDN);
					BDset[thei][thet].resize(BDBN[thei][thet],thedual);
				}
				BDN+=1;
				TBDN+=1;
			}
			if (Pintsol==1){
				cout<<"integral sub"<<endl;
				PLcost=uppsc;
				cout<<"a new upper bound is found by branching in the second stage"<<endl;	
			}
			cout<<"thegap="<<thegap<<endl;
		}
		if (mintsol==0){
			feasi=0;
			double mfv=-1; 
			int mcol=-1;
			for (IloInt j = 0; j <NN; j++) {
				double trv=lpsolver.getValue(x[j+1+FIXN+K]);
				if (trv>0.001){
					if (trv<0.99){
						if (mfv<trv){
							mfv=trv;
							mcol=j;
						}
					}
				}
			}
			FIXN+=1;
			FIXcolves.resize(FIXN,colves[mcol]);
			FIXcolberth.resize(FIXN,colberth[mcol]);
			FIXcolcost.resize(FIXN,colcost[mcol]);
			for (int tt=0;tt!=3;++tt){
				FIXcoltimes[tt].resize(FIXN,coltimes[tt][mcol]);
			}
		}
		env.end();
	}
	cout<<"a new Vescost is found by branching in the second stage: "<<Vescost<<endl;
	return lwbd;
}

double pmastersolver02(){ 
	int feasi=0;
	double lwbd;
	while (feasi==0){
		feasi=1;
		PinputData (1); 
		IloEnv env;      
		IloModel msmodel(env);
		IloCplex lpsolver(msmodel);
		lpsolver.setOut(env.getNullStream());
		lpsolver.setParam(IloCplex::Threads, 1); 
		IloNumVarArray x(env);  
		IloInt i; 
		PTotalcost = IloAdd(msmodel, IloMinimize(env));
		IloNumArray taskreach(env, ITN); 
		for (i=0;i!=ITN;++i){taskreach[i]=ITres[i];} 
		PTask = IloAdd(msmodel, IloRangeArray(env, taskreach, IloInfinity));  
		PTask02 = IloAdd(msmodel, IloRangeArray(env, -IloInfinity, taskreach));  
		IloNumArray PFIXreach(env, PFIXN); 
		for (i=0;i!=PFIXN;++i){PFIXreach[i]=1;} 
		PFIXcon=IloAdd(msmodel, IloRangeArray(env, PFIXreach,IloInfinity)); 
		PInicolload(msmodel,x);
		lwbd=pmasterproblem(msmodel,lpsolver,x,PNN); 
		int ncs=pcolgen();
		while (ncs>0){
			lwbd=pmasterproblem(msmodel,lpsolver,x,PNN);
			ncs=pcolgen();
		}
		t_crt=clock();
		if (t_crt-t_start>=uptime*1000){
			cout<<"Time limit reached"<<endl;
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			break;
		}
		Pintsol=1;
		for (IloInt j = 0; j <PNN; j++) {  
			double trv=lpsolver.getValue(x[j+ITN+PFIXN]);		
			if (trv>0.0001){
				if (trv<0.99){Pintsol=0;}
			}
		}
		if (Pintsol==0){ 
			double tempd;
			double minscore=-1;
			for (IloInt j = 0; j <PNN; j++) {  
				double trv=lpsolver.getValue(x[j+ITN+PFIXN]);		
				if (trv>0.0001){
					if (trv<0.99){
						if (minscore<trv){
							minscore=trv;
							tempd=j;
						}
					}  
				}
			}
			feasi=0;
			PFIXN+=1;
			int thelen=pcollen[tempd];
			FIXpcollen.resize(PFIXN,thelen);
			FIXpcoltasks.resize(PFIXN);
			for (int nn=0;nn!=thelen;++nn){
				int thect=pcoltasks[tempd][nn]; 
				FIXpcoltasks[PFIXN-1].resize(nn+1,thect);
			}
			double thecost=pcolcost[tempd];
			FIXpcolcost.resize(PFIXN,thecost);
		}
		if (Pintsol==1){ 
		    PLcost=lwbd;
		    cout<<"a new upper bound is found by branching in the third stage"<<endl;	
		}
		env.end();
	}
	return lwbd;
}

void threephase(){
	rtobj=mastersolver();
	if (mintsol!=1){
		secondphase();
	}
	if (Pintsol!=1 && Vescost<LL-1){
		pmastersolver02();
	}
	upperbound=Vescost+PLcost;
	totalgap=(upperbound-rtobj)/rtobj*100;
}

void solvebap(){
	inputData();
	threephase();
}

void reswrite(){
	cout <<"CPU time:"<<double(t_end-t_start)/double(1000)<<endl;
	cout <<"Upper bound:"<<upperbound<<endl;
	cout <<"Gap:"<<totalgap<<endl;
}

int main (int argc, char **argv) {
	t_start=clock();
	cout << "formulation" << endl;
	solvebap();
	t_end =clock();
	reswrite();
	cout << "succeeded" << endl;
	return 0;
}
