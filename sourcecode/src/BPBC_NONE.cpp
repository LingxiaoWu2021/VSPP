#include <ilcplex/ilocplex.h>   /* cplex */    
#include <vector>              
#include <omp.h>               /* parallel */
#include "Selfmath.h"

namespace patch {template < typename T > std::string to_string( const T& n ){std::ostringstream stm; stm << n; return stm.str() ;}}

using namespace std;
////////////////////////////////////////////////////////
//                                                    //
// Source CPP Code for the BPBC Algorithm without Enhancements
// Vessel Service Planning in Seaports, Operations Research
//                                                  
// Authors: Lingxiao Wu, Yossiri Adulyasak, Jean-Francois Cordeau, Shuaian Wang 
///////////////////////////////////////////////////////

//input data starts here

extern const int S = 6;
extern const int K =10;
extern const int T = 288;
extern const int B = 10;
extern const int I = 20;
extern const int NCPN = 0;
extern const int HWPN = 180;
int BRT[B]={0,14,0,21,6,47,20,0,22,44};
int Chaocu[B]={-1,-1,-1,-1,-1,-1,-1,-1,-1,51};
int HDT[B]={-1,15,-1,22,7,48,21,-1,23,45};
int E[I][2]={{0,39},{0,28},{23,71},{29,77},{38,86},{62,110},{87,135},{93,141},{101,149},{140,188},{59,107},{71,119},{83,131},{145,193},{150,198},{133,181},{160,208},{161,209},{174,222},{216,264}};
int BRK[S][2]={{14,34},{62,82},{110,130},{158,178},{206,226},{254,274}};
int VLL[K]={0,0,0,2,1,1,0,0,0,0};
int F[I][I]={{0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0}};
int D[I+1]={7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,6};
int H[K][B]={{52,52,52,52,52,52,52,52,52,52},{64,64,64,64,64,64,64,64,64,64},{53,53,53,53,53,53,53,53,53,53},{109,109,109,109,109,109,109,109,109,109},{105,105,105,105,105,105,105,105,105,105},{64,64,64,64,64,64,64,64,64,64},{66,66,66,66,66,66,66,66,66,66},{61,61,61,61,61,61,61,61,61,61},{66,66,66,66,66,66,66,66,66,66},{69,69,69,69,69,69,69,69,69,69}};
int Q[I+1][I+1]={{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};
int ST[S][2]={{0,47},{48,95},{96,143},{144,191},{192,239},{240,287}};
int C1[K]={50000,50000,50000,50000,50000,50000,50000,50000,50000,50000};
int C2[I][T]={{0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,524,526,528,530,532,534,536,538,540,542,544,546,548,550,552,554,556,558,560,562,564,566,568,570,572,574},{0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,524,526,528,530,532,534,536,538,540,542,544,546,548,550,552,554,556,558,560,562,564,566,568,570,572,574},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,524,526,528},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138,144,150,156,162,168,174,180,186,192,198,204,210,216,222,228,234,240,246,252,258,264,270,276,282,288,294,300,306,312,318,324,330,336,342,348,354,360,366,372,378,384,390,396,402,408,414,420,426,432,438,444,450,456,462,468,474,480,486,492,498,504,510,516,522,528,534,540,546,552,558,564,570,576,582,588,594,600,606,612,618,624,630,636,642,648,654,660,666,672,678,684,690,696,702,708,714,720,726,732,738,744,750,756,762,768,774,780,786,792,798,804,810,816,822,828,834,840,846,852,858,864,870,876,882,888,894,900,906,912,918,924,930,936,942,948,954,960,966,972,978,984,990,996,1002,1008,1014,1020,1026,1032,1038,1044,1050,1056,1062,1068,1074,1080,1086,1092,1098,1104,1110,1116,1122,1128,1134,1140,1146,1152,1158,1164,1170,1176,1182,1188,1194,1200,1206,1212,1218,1224,1230,1236,1242,1248,1254,1260,1266,1272,1278,1284,1290,1296,1302,1308,1314,1320,1326,1332,1338,1344,1350,1356,1362,1368,1374,1380,1386,1392,1398,1404,1410,1416,1422,1428,1434,1440,1446,1452,1458,1464,1470,1476,1482,1488,1494,1500,1506,1512,1518,1524,1530,1536,1542,1548},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864,868,872,876,880,884,888,892,896,900,904,908,912,916,920,924,928,932,936,940,944,948,952,956,960,964,968,972,976,980,984,988,992,996},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99,102,105,108,111,114,117,120,123,126,129,132,135,138,141,144,147,150,153,156,159,162,165,168,171,174,177,180,183,186,189,192,195,198,201,204,207,210,213,216,219,222,225,228,231,234,237,240,243,246,249,252,255,258,261,264,267,270,273,276,279,282,285,288,291,294,297,300,303,306,309,312,315,318,321,324,327,330,333,336,339,342,345,348,351,354,357,360,363,366,369,372,375,378,381,384,387,390,393,396,399,402,405,408,411,414,417,420,423,426,429,432,435,438,441,444,447,450,453,456,459,462,465,468,471,474,477,480,483,486,489,492,495,498,501,504,507,510,513,516,519,522,525,528,531,534,537,540,543,546,549,552,555,558,561,564,567,570,573,576,579,582,585,588,591,594,597,600,603,606,609,612,615,618,621,624,627,630,633,636,639,642,645,648,651,654,657,660,663,666,669,672,675},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864,868,872,876,880,884,888,892,896,900,904,908,912},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,24,36,48,60,72,84,96,108,120,132,144,156,168,180,192,204,216,228,240,252,264,276,288,300,312,324,336,348,360,372,384,396,408,420,432,444,456,468,480,492,504,516,528,540,552,564,576,588,600,612,624,636,648,660,672,684,696,708,720,732,744,756,768,780,792,804,816,828,840,852,864,876,888,900,912,924,936,948,960,972,984,996,1008,1020,1032,1044,1056,1068,1080,1092,1104,1116,1128,1140,1152,1164,1176,1188,1200,1212,1224,1236,1248,1260,1272,1284,1296,1308,1320,1332,1344,1356,1368,1380,1392,1404,1416,1428,1440,1452,1464,1476,1488,1500,1512,1524,1536,1548,1560,1572,1584,1596,1608,1620,1632,1644,1656,1668,1680,1692,1704},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136,144,152,160,168,176,184,192,200,208,216,224,232,240,248,256,264,272,280,288,296,304,312,320,328,336,344,352,360,368,376,384,392,400,408,416,424,432,440,448,456,464,472,480,488,496,504,512,520,528,536,544,552,560,568,576,584,592,600,608,616,624,632,640,648,656,664,672,680,688,696,704,712,720,728,736,744,752,760,768,776,784,792,800,808,816,824,832,840,848,856,864,872,880,888,896,904,912,920,928,936,944,952,960,968,976,984,992,1000,1008,1016,1024,1032,1040,1048,1056,1064,1072,1080,1088,1096},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138,144,150,156,162,168,174,180,186,192,198,204,210,216,222,228,234,240,246,252,258,264,270,276,282,288,294,300,306,312,318,324,330,336,342,348,354,360,366,372,378,384,390,396,402,408,414,420,426,432,438,444,450,456,462,468,474,480,486,492,498,504,510,516,522,528,534,540,546,552,558,564,570,576,582,588,594,600,606,612,618,624,630,636,642,648,654,660,666,672,678,684,690,696,702,708,714,720,726,732,738,744,750,756,762,768,774,780,786,792,798,804,810,816,822,828,834,840,846,852,858,864,870,876,882,888,894,900,906,912,918,924},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284}};
int C3[K][B]={{330,260,309,356,382,302,263,348,354,333},{442,371,352,438,461,454,378,320,323,416},{337,310,352,371,334,299,315,268,376,305},{703,676,719,600,621,779,807,692,627,545},{557,698,693,588,662,761,704,557,588,751},{336,355,336,467,326,403,406,400,454,339},{429,469,399,393,403,333,416,403,416,379},{375,345,345,448,305,381,378,308,323,393},{330,439,469,393,353,360,442,406,406,347},{466,469,414,373,449,490,480,421,500,511}};
int C4[S]={48,48,48,48,48,48};
int ODS[2][1]={{},{}};
int Hset[2][HWPN]={{0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19},{1,2,3,4,5,6,7,8,9,0,2,3,4,5,6,7,8,9,0,1,3,4,5,6,7,8,9,0,1,2,4,5,6,7,8,9,0,1,2,3,5,6,7,8,9,0,1,2,3,4,6,7,8,9,0,1,2,3,4,5,7,8,9,0,1,2,3,4,5,6,8,9,0,1,2,3,4,5,6,7,9,0,1,2,3,4,5,6,7,8,11,12,13,14,15,16,17,18,19,10,12,13,14,15,16,17,18,19,10,11,13,14,15,16,17,18,19,10,11,12,14,15,16,17,18,19,10,11,12,13,15,16,17,18,19,10,11,12,13,14,16,17,18,19,10,11,12,13,14,15,17,18,19,10,11,12,13,14,15,16,18,19,10,11,12,13,14,15,16,17,19,10,11,12,13,14,15,16,17,18}};

//input data ends here


double uptime=3600; 
double totalerr=0.00001; 

int BTN=0; 
int BTindex[B][T];
int GTN=0;
int GTindex[NCPN+1][T]; 
int HTN=0;   
int HTindex[HWPN][T];


int TSdn[T]; 
vector<vector<int>> TSdex(T); 
int LL=999999;
int PLL=999999;

int levels=0;
double upperbound;
double totallb;
double	pupperbound=PLL;
double	ptotallb=-PLL;
double totalgap;
vector<int> nodenum;   
vector<vector<vector<int>>> nodeindx;   
vector<vector<double>> lowerbound;   
vector<vector<vector<int>>> brcho(2);   
vector<vector<int>> brtype;  
vector<vector<int>> brnd1;
vector<vector<int>> brnd2; 

int N; 
int NN; 
int TON;
int PN; 
int PNN; 
int PTON; 

vector <int> colves;   
vector <int> colberth;   
vector <double> colcost;   
vector<vector<int>> coltimes(3);   
vector <int> pcolshift;   
vector <double> pcolcost;   
vector<int> pcollen;  
vector<vector<int>> pcoltasks;  

int numused=0;
vector<int> usedcol;
vector<double> usedcolval;
int pnumused=0; 
vector<int> pusedcol;
vector<double> pusedcolval;

ILOSTLBEGIN 
IloObjective   Totalcost;
IloRangeArray  Vessel;
IloRangeArray  Berocu;
IloRangeArray  Hdway;
IloRangeArray  Noncro;
IloRangeArray  Bendcon; 
IloRangeArray  ENcon; 

IloObjective   PTotalcost;
IloRangeArray  PTask;
IloRangeArray  PTask02; 

double vesdual [K]; 
vector<double> berocudual;
vector<double> hdwaydual; 
vector<double> noncrodual;
vector<double> bdsdual;
vector<double> ptaskdual;  

int SITN[S]; 
vector<vector<int>> SIS(S);
int nt1used[K]; 
int nt3used[K]; 
vector<vector<int>> usedt1(K); 
vector<vector<int>> usedt3(K);

int BSEQ[K][B]; 
double T1result[K][T];
double T3result[K][T];
int ITN=0; 
int Iset[I*T];
int Tset[I*T];
vector<double> ITres;

int BDN=0; 
int TBDN=0; 
int BDBN[I][T]; 
vector<vector<vector<int>>> BDindset(I);  
vector<vector<vector<double>>> BDset(I); 

int VKB[K][B]; 
int VIS[I][S]; 
int VIT[I][T];  
int OVIT[I][T]; 
int PIID[I+2][I+2];  
int Pintsol=0;

extern const int TTRD=6; 
int PRTN[TTRD];
vector<vector<int>> PVset(TTRD);
vector<vector<int>> PBset(TTRD);
int NCOLN[TTRD];
vector <vector <int>> prcolves(TTRD);  
vector <vector <int>> prcolberth(TTRD);   
vector <vector <double>> prcolcost(TTRD);  
vector <vector<vector<int>>> prcoltimes(TTRD);   

int PPRTN[TTRD];
vector<vector<int>> PPSset(TTRD);
vector <vector <int>> prpcolshift(TTRD);   
vector <vector <double>> prpcolcost(TTRD);   
vector <vector<int>> prpcollen(TTRD);   
vector <vector<vector<int>>> prpcoltasks(TTRD);   

clock_t t_start,t_end,t_crt; 

void PRLsetup(){
	for (int tt=0;tt!=TTRD;++tt){
		PRTN[tt]=0;
		prcoltimes[tt].resize(3);
		PPRTN[tt]=0;
	}
	int basen=floor(double(K*B)/double(TTRD));
	for (int nn=0;nn!=TTRD;++nn){
		PRTN[nn]=basen;
	}
	int leftn=K*B-basen*TTRD;
	for (int nn=0;nn!=leftn;++nn){
		PRTN[nn]+=1;
	}
	int thetd=0;
	int theno=0;
	for (int k=0;k!=K;++k){ 
		for (int b=0;b!=B;++b){	
			PVset[thetd].resize(theno+1,k);
			PBset[thetd].resize(theno+1,b);
			theno+=1;
			if (theno>=PRTN[thetd]){
				thetd+=1;
				theno=0;
			}
		}	
	}
	basen=floor(double(S)/double(TTRD));
	for (int nn=0;nn!=TTRD;++nn){
		PPRTN[nn]=basen;
	}
	leftn=S-basen*TTRD;
	for (int nn=0;nn!=leftn;++nn){
		PPRTN[nn]+=1;
	}
	thetd=0;
	theno=0;
	for (int s=0;s!=S;++s){
		PPSset[thetd].resize(theno+1,s);
		theno+=1;
		if (theno>=PPRTN[thetd]){
			thetd+=1;
			theno=0;
		}
	}	
}

void CGsetup(){
	for (int i=0;i!=I;++i){
		BDindset[i].resize(T); 
		BDset[i].resize(T);
	}
	for (int i=0;i!=I;++i){
		for (int t=0;t!=T;++t){
			BDBN[i][t]=0;
		}
	}
	for (int b=0;b!=B;++b){
		for (int t=0;t!=T;++t){
			BTindex[b][t]=BTN; 
			BTN+=1;
		}
	}
	for (int s=0;s!=S;++s){
		for (int t=ST[s][0];t<=ST[s][1];++t){
			TSdn[t]=0; 
		}
	}
	for (int s=0;s!=S;++s){
		for (int t=ST[s][0];t<=ST[s][1];++t){
			TSdn[t]+=1; 
			TSdex[t].resize(TSdn[t],s);
		}
	}
	for (int i=0;i!=I;++i){
		for (int t=E[i][0];t<=E[i][1];++t){
			OVIT[i][t]=1;
		}
	}    
	for (int i=K;i!=2*K;++i){
		for (int b=0;b!=B;++b){
			int timet=BRT[b];
			int edtime=HDT[b];  
			if (HDT[b]!=-1){ 
				for (int tt=timet;tt<edtime;++tt){
					OVIT[i][tt]=0;}}
		}
	}
	for (int i=0;i!=K;++i){
		if (VLL[i]>=2){
			for (int b=0;b!=B;++b){
				int time02=Chaocu[b];
				if (time02!=-1){
					int timet=BRT[b];
					for (int t=timet;t<=time02-1;++t){
						OVIT[i][t]=0;
					}
				}
			}
		}
	}
	for (int i=0;i!=I;++i){
		for (int t=E[i][0];t<=E[i][1];++t){
			int doable=0;
			for (int n=0;n!=TSdn[t];++n){
				int thes=TSdex[t][n]; 
				if (BRK[thes][0]+D[I]<=t){
					doable=1;
					break;
				}
				if (t+D[i]<=BRK[thes][1]){
					doable=1;
					break;
				}
			}
			OVIT[i][t]=doable; 
		}
	}
	for (int n=0;n!=HWPN;++n){ 
		for (int t=0;t!=T;++t){
			HTindex[n][t]=HTN;
			HTN+=1; 
		}
	}
	for (int n=0;n!=NCPN;++n){
		for (int t=0;t!=T;++t){
			GTindex[n][t]=GTN; 
			GTN+=1;
		}
	}
	noncrodual.resize(GTN);
	hdwaydual.resize(HTN);
	berocudual.resize(BTN);
}

void inputData () { 
	PRLsetup();
	CGsetup();
	upperbound=LL;
	totallb=-LL;
	for (int k=0;k!=K;++k){
		double BScost[B];
		for (int b=0;b!=B;++b){
			BScost[b]=C3[k][b];
		}
		for (int b=0;b!=B;++b){
			int theb=mathmin03(BScost,B);
			BSEQ[k][b]=theb;
			BScost[theb]=999999;
		}
	}
}

void Inicolload(IloModel model,IloNumVarArray x){ 
	IloEnv env = model.getEnv(); 
	IloInt i,j,k;   
	IloNumArray vescover(env, K);     
	IloNumArray berocu(env,BTN);    
	IloNumArray headway(env, HTN);
	IloNumArray noncro(env, GTN);    
	IloNumArray bencro(env, BDN);    
	IloNumArray encro(env, 1);   
	{ 
		for (k=0;k!=K;++k){vescover[k]=0;}
		for (i=0;i!=BTN;++i){berocu[i]=0;}
		for (i=0;i!=HTN;++i){headway[i]=0;}
		for (i=0;i!=GTN;++i){noncro[i]=0;}
		for (i=0;i!=BDN;++i){bencro[i]=1;}
		encro[0]=1;
		x.add(IloNumVar(Totalcost(1) + Vessel(vescover)+Berocu(berocu)+Hdway(headway)+Noncro(noncro)+Bendcon(bencro)+ENcon(encro)));  
	}
	for (j = 0; j < K; j++) {  
		for (k=0;k!=K;++k){vescover[k]=0;}
		for (i=0;i!=BTN;++i){berocu[i]=0;}
		for (i=0;i!=HTN;++i){headway[i]=0;}
		for (i=0;i!=GTN;++i){noncro[i]=0;}
		for (i=0;i!=BDN;++i){bencro[i]=0;}
		encro[0]=0;
		vescover[j]=1;
		x.add(IloNumVar(Totalcost(C1[j]) + Vessel(vescover)+Berocu(berocu)+ Hdway(headway)+Noncro(noncro)+Bendcon(bencro)+ENcon(encro))); 
	}
	N=0;
	NN=N;
	TON=0; 
	vector<int>().swap(colves);
	vector<int>().swap(colberth);
	vector<double>().swap(colcost);
	for (int nn=0;nn!=3;++nn){ 
		vector<int>().swap(coltimes[nn]);
	}
	numused=0;
	vector<int>().swap(usedcol);
	vescover.end();
	berocu.end();
	headway.end();
	noncro.end();
	bencro.end();
	encro.end();
}

double masterproblem (IloModel model,IloCplex lpsolver,IloNumVarArray x,int numsc) {
	IloEnv env = model.getEnv(); 
	double MVAL;
	double optvalue;
	IloInt j,k,i,t1;   
	IloNumArray vescover(env, K);     
	IloNumArray berocu(env,BTN);    
	IloNumArray headway(env, HTN);
	IloNumArray noncro(env, GTN);     
	IloNumArray bencro(env, BDN);     
	IloNumArray encro(env, 1);     
	try{
		for (j = N; j < numsc; j++) {  
			int thecol=j; 
			for (k=0;k!=K;++k){vescover[k]=0;}
			for (i=0;i!=BTN;++i){berocu[i]=0;}
			for (i=0;i!=HTN;++i){headway[i]=0;}
			for (i=0;i!=GTN;++i){noncro[i]=0;}
			for (i=0;i!=BDN;++i){bencro[i]=0;}
			encro[0]=0;
			int theves=colves[thecol]; 
			vescover[theves]=1;
			int thet1=coltimes[0][thecol]; 
			int thet3=coltimes[2][thecol]; 
			for (int n=0;n!=HWPN;++n){
				int thei=Hset[0][n];
				int thej=Hset[1][n];
				if (theves==thei){ 
					int et1=thet1+F[theves][thej]-1;  
					if (et1>T-1){et1=T-1;}
					for (t1=thet1;t1<=et1;++t1){
						int theind=HTindex[n][t1]; 
						headway[theind]=1;
					}
				}
				if (theves==thej){ 
					int theind=HTindex[n][thet1]; 
					headway[theind]=1;
				}
				if (theves+K==thei){ 
					int et3=thet3+F[theves+K][thej]-1;  
					if (et3>T-1){et3=T-1;}
					for (t1=thet3;t1<=et3;++t1){
						int theind=HTindex[n][t1]; 
						headway[theind]=1;
					}
				}
				if (theves+K==thej){ 
					int theind=HTindex[n][thet3]; 
					headway[theind]=1;
				}
			}
			for (int n=0;n!=NCPN;++n){
				int thei=ODS[0][n];
				int thej=ODS[1][n];
				if (theves==thei || theves==thej){ 
					int et01=thet1+D[theves]-1;  
					if (et01>T-1){et01=T-1;}
					for (t1=thet1;t1<=et01;++t1){
						int theind=GTindex[n][t1];
						noncro[theind]=1;
					}			 
				}
				if (theves+K==thei || theves+K==thej){ 
					int et03=thet3+D[theves+K]-1;  
					if (et03>T-1){et03=T-1;}
					for (t1=thet3;t1<=et03;++t1){
						int theind=GTindex[n][t1];
						noncro[theind]=1;
					}			 
				}
			}
			int theber=colberth[thecol];
			int thet2=coltimes[1][thecol];
			int et2=thet3-1; 
			for (t1=thet2;t1<=et2;++t1){
				int theind=BTindex[theber][t1];
				berocu[theind]=1;
			}
			for (int nn=0;nn!=BDBN[theves][thet1];++nn){
				int thebn=BDindset[theves][thet1][nn];
				double thecof=BDset[theves][thet1][nn];
				bencro[thebn]-=thecof;

			}
			for (int nn=0;nn!=BDBN[theves+K][thet3];++nn){
				int thebn=BDindset[theves+K][thet3][nn];
				double thecof=BDset[theves+K][thet3][nn];
				bencro[thebn]-=thecof;
			}
			double thecost=colcost[thecol];
			x.add(IloNumVar(Totalcost(colcost[thecol])+Vessel(vescover)+Berocu(berocu)+Hdway(headway)+Noncro(noncro)+Bendcon(bencro)+ENcon(encro))); 
		}
		{
			lpsolver.solve();
			optvalue=LL;
			if(lpsolver.getStatus() ==IloAlgorithm::Optimal){
				optvalue=lpsolver.getObjValue();
				vector<double>().swap(bdsdual);
				bdsdual.resize(BDN);
				for (i = 0; i < K; i++) {
					vesdual[i] = lpsolver.getDual(Vessel[i]);
				}
				for (i=0;i<BTN; i++){
					berocudual[i]=lpsolver.getDual(Berocu[i]);
				}
				for (i = 0; i < HTN; i++) {
					hdwaydual[i] = lpsolver.getDual(Hdway[i]);
				}
				for (i=0;i<GTN; i++){
					noncrodual[i]=lpsolver.getDual(Noncro[i]);
				}
				for (i=0;i<BDN; i++){
					bdsdual[i]=lpsolver.getDual(Bendcon[i]);
				}
			}
			MVAL=lpsolver.getObjValue();
		}
	}
	catch(IloException& ex){
		cerr << ex << endl;
	}
	catch(...){
		cerr << "Error..." << endl;
	}
	N=NN; 
	vescover.end();
	headway.end();
	noncro.end();
	berocu.end();
	bencro.end();
	encro.end();
	return MVAL; 
}

void netload(int lel,int ind,int branch){ 
	for (int k=0;k!=K;++k){
		for (int b=0;b!=B;++b){
			VKB[k][b]=1; 
		}
	}
	for (int i=0;i!=I;++i){
		for (int s=0;s!=S;++s){
			VIS[i][s]=1;
		}
	}
	for (int i=0;i!=I;++i){
		for (int t=E[i][0];t<=E[i][1];++t){
			VIT[i][t]=OVIT[i][t];
		}
	}    
	for (int i=0;i!=I+2;++i){
		for (int j=0;j!=I+2;++j){
			PIID[i][j]=1;
		}
	}
	int thelel=lel;
	int theind=ind;
	int thebranch=branch;
	while (theind!=-1){
		int thetype=brtype[thelel][theind]; 
		int then1=brnd1[thelel][theind]; 
		int then2=brnd2[thelel][theind]; 
		if (thebranch==0){
			if (thetype==1){
				VKB[then1][then2]=0;
			}
			if (thetype==2){ 
				VIT[then1][then2]=0;
			}
			if (thetype==3){ 
				VIS[then1][then2]=0;
			}
			if (thetype==4){ 
				PIID[then1][then2]=0;
			}
		}
		if (thebranch==1){
			if (thetype==1){ 
				for (int i=0;i<then2;++i){
					VKB[then1][i]=0;
				}
				for (int i=then2+1;i<B;++i){
					VKB[then1][i]=0;
				}
			}
			if (thetype==2){ 
				for (int i=E[then1][0];i<then2;++i){
					VIT[then1][i]=0;
				}
				for (int i=then2+1;i<=E[then1][1];++i){
					VIT[then1][i]=0;
				}
			}
			if (thetype==3){ 
				for (int i=0;i<then2;++i){
					VIS[then1][i]=0;
				}
				for (int i=then2+1;i<S;++i){
					VIS[then1][i]=0;
				}
			}
			if (thetype==4){ 
				if (then1!=I && then1!=I+1){
					for (int i=0;i<then2;++i){
						PIID[then1][i]=0;
					}
					for (int i=then2+1;i<I+2;++i){
						PIID[then1][i]=0;
					}}
				if (then2!=I && then2!=I+1){
					for (int i=0;i<then1;++i){
						PIID[i][then2]=0;
					}
					for (int i=then1+1;i<I+2;++i){
						PIID[i][then2]=0;
					}
				}
			}
		}
		int tempind=nodeindx[thelel][theind][0];
		int tempbranch=nodeindx[thelel][theind][1];
		theind=tempind;
		thebranch=tempbranch;
		thelel-=1;
	}
}

void pathgen(int thev, int berth, int thread){ 
	double acpbd=-0.001;
	int CA[2]; 
	int CB[2];  
	double basecost=0; 
	basecost+=C3[thev][berth]; 
	basecost-=vesdual[thev];
	CA[0]=E[thev][0];
	CA[1]=E[thev][1];
	if (CA[0]<BRT[berth]-D[thev]){ 
		CA[0]=BRT[berth]-D[thev];
	}
	CB[0]=E[thev+K][0];
	CB[1]=E[thev+K][1];
	if (CB[0]<CA[0]+D[thev]+H[thev][berth]){
		CB[0]=CA[0]+D[thev]+H[thev][berth];
	}
	if (CA[1]>CB[1]-D[thev+K]-H[thev][berth]){
		CA[1]=CB[1]-D[thev+K]-H[thev][berth];
	}
	int flt1=-1; 
	int flt2=-1;  
	int fls1=-1;
	int flt3=-1;  
	int fls3=-1; 
	double flcost=LL; 
	for (int t=CA[0];t<=CA[1];++t){
		if (VIT[thev][t]==0){
			continue;}
		int tt1=t;
		int tt2=t+D[thev];
		double trc=basecost; 
		trc+=C2[thev][tt1];
		for (int gg=0;gg!=HWPN;++gg){
			int thei=Hset[0][gg];
			int thej=Hset[1][gg];
			if (thev==thei){ 
				int et1=tt1+F[thev][thej]-1;
				if (et1>T-1){et1=T-1;}
				for (int t1=tt1;t1<=et1;++t1){
					int theind=HTindex[gg][t1];
					trc-=hdwaydual[theind];
				}
			}
			if (thev==thej){ 
				int theind=HTindex[gg][tt1]; 
				trc-=hdwaydual[theind];
			}
		}
		for (int gg=0;gg!=NCPN;++gg){
			int thei=ODS[0][gg];
			int thej=ODS[1][gg];
			if (thev==thei || thev==thej){
				int etgg1=tt1+D[thev]-1;
				if (etgg1>T-1){
					etgg1=T-1;
				}
				for (int hh=tt1;hh<=etgg1;++hh){
					int theind=GTindex[gg][hh];
					trc-=noncrodual[theind];
				}		 
			}
		}
		for (int nn=0;nn!=BDBN[thev][tt1];++nn){
			int thebd=BDindset[thev][tt1][nn];
			double thecof=BDset[thev][tt1][nn];
			trc+=bdsdual[thebd]*thecof;}
		double ftrc=trc;
		int eet3=tt2+H[thev][berth];  
		for (int t3=eet3;t3<=CB[1];++t3){  
			trc=ftrc;
			if (VIT[thev+K][t3]==0){
				continue;}
			int tt3=t3;
			trc+=C2[thev+K][tt3]; 
			for (int hh=tt2;hh<tt3;++hh){ 
				int theind=BTindex[berth][hh];
				trc-=berocudual[theind];
			}
			for (int gg=0;gg!=HWPN;++gg){
				int thei=Hset[0][gg];
				int thej=Hset[1][gg];
				if (thev+K==thei){ 
					int et3=tt3+F[thev+K][thej]-1;
					if (et3>T-1){et3=T-1;}
					for (int t1=tt3;t1<=et3;++t1){
						int theind=HTindex[gg][t1]; 
						trc-=hdwaydual[theind];
					}
				}
				if (thev+K==thej){ 
					int theind=HTindex[gg][tt3]; 
					trc-=hdwaydual[theind];
				}
			}
			for (int gg=0;gg!=NCPN;++gg){
				int thei=ODS[0][gg];
				int thej=ODS[1][gg];
				if (thev+K==thei || thev+K==thej){
					int etgg3=tt3+D[thev+K]-1;
					if (etgg3>T-1){
						etgg3=T-1;
					}
					for (int hh=tt3;hh<=etgg3;++hh){
						int theind=GTindex[gg][hh];
						trc-=noncrodual[theind];
					}		 
				}
			}
			for (int nn=0;nn!=BDBN[thev+K][tt3];++nn){
				int thebd=BDindset[thev+K][tt3][nn];
				double thecof=BDset[thev+K][tt3][nn];
				trc+=bdsdual[thebd]*thecof;}
			if (trc<flcost){
				flcost=trc; 
				flt1=tt1;
				flt2=tt2;
				flt3=tt3;
			}
		}
	}
	if (flcost<acpbd){ 
		NCOLN[thread]+=1;
		prcolves[thread].resize(NCOLN[thread],thev);
		prcolberth[thread].resize(NCOLN[thread],berth);
		prcoltimes[thread][0].resize(NCOLN[thread],flt1);
		prcoltimes[thread][1].resize(NCOLN[thread],flt2);
		prcoltimes[thread][2].resize(NCOLN[thread],flt3);
		double comcost=0;
		comcost+=C2[thev][flt1]+C2[thev+K][flt3]+C3[thev][berth];
		prcolcost[thread].resize(NCOLN[thread],comcost);
	}
}

int colgen(int lel, int ind, int branch){ 
	int newcol=0;	
	for (int nn=0;nn!=TTRD;++nn){
		NCOLN[nn]=0;
		vector<int>().swap(prcolves[nn]);
		vector<int>().swap(prcolberth[nn]);
		vector<double>().swap(prcolcost[nn]);
		for (int mm=0;mm!=3;++mm){
			vector<int>().swap(prcoltimes[nn][mm]);
		}
	}
#pragma omp parallel sections num_threads(6)
	{
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[0];++mm){
				int k=PVset[0][mm];
				int b=PBset[0][mm];
				if (VKB[k][b]==1){
					pathgen(k,b,0);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[1];++mm){
				int k=PVset[1][mm];
				int b=PBset[1][mm];
				if (VKB[k][b]==1){
					pathgen(k,b,1);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[2];++mm){
				int k=PVset[2][mm];
				int b=PBset[2][mm];
				if (VKB[k][b]==1){
					pathgen(k,b,2);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[3];++mm){
				int k=PVset[3][mm];
				int b=PBset[3][mm];
				if (VKB[k][b]==1){
					pathgen(k,b,3);}
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[4];++mm){
				int k=PVset[4][mm];
				int b=PBset[4][mm];
				if (VKB[k][b]==1){
					pathgen(k,b,4);}
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[5];++mm){
				int k=PVset[5][mm];
				int b=PBset[5][mm];
				if (VKB[k][b]==1){
					pathgen(k,b,5);}
			}
		}									
	}
	for (int thread=0;thread!=TTRD;++thread){
		newcol+=NCOLN[thread];
		for (int mm=0;mm!=NCOLN[thread];++mm){
			NN+=1; 
			TON+=1;
			int thev=prcolves[thread][mm];
			colves.resize(TON,thev);
			int berth=prcolberth[thread][mm];
			colberth.resize(TON,berth);
			int tt1=prcoltimes[thread][0][mm];
			coltimes[0].resize(TON,tt1);
			int tt2=prcoltimes[thread][1][mm];
			coltimes[1].resize(TON,tt2);
			int tt3=prcoltimes[thread][2][mm];
			coltimes[2].resize(TON,tt3);
			double thecost=prcolcost[thread][mm];
			colcost.resize(TON,thecost);
		}
	} 
	return newcol;
}

void PCGsetup(int create){ 
	if (create==1){
		ITN=0;
		for (int k=0;k!=K;++k){
			for (int n=0;n!=nt1used[k]; ++n){
				int thet=usedt1[k][n];
				Iset[ITN]=k;
				Tset[ITN]=thet;
				ITN+=1;
			}
		}
		for (int k=0;k!=K;++k){
			for (int n=0;n!=nt3used[k]; ++n){
				int thet=usedt3[k][n];
				Iset[ITN]=k+K;
				Tset[ITN]=thet;
				ITN+=1;
			}
		}
	}
	InsertionSort(Tset,Iset,ITN);  
	if (create==1){
		vector<double>().swap(ITres);
		ITres.resize(ITN); 
		for (int nn=0;nn!=ITN;++nn){
			int thei=Iset[nn];
			int thet=Tset[nn];
			if (thei<K){
				ITres[nn]=T1result[thei][thet];}
			else {
				ITres[nn]=T3result[thei-K][thet];
			}
		}
	}
	vector<double>().swap(ptaskdual);
	ptaskdual.resize(ITN);
}

void Pshrink(){
	for (int s=0;s!=S;++s){
		SITN[s]=0; 
	}
	for (int s=0;s!=S;++s){
		vector<int>().swap(SIS[s]);
	}
	for (int n=0;n!=ITN;++n){
		int thei=Iset[n];
		int thet=Tset[n];
		for (int m=0;m!=TSdn[thet];++m){
			int thes=TSdex[thet][m];
			SITN[thes]+=1;
			SIS[thes].resize(SITN[thes],n);
		}
	}
}

void PinputData (int create) { 
	PCGsetup(create);
	Pshrink();
	pupperbound=PLL;
	ptotallb=-PLL;
	vector<int>().swap(pcolshift);	
	vector<double>().swap(pcolcost);	
	vector<int>().swap(pcollen);	
	for (int nn=0;nn!=PTON;++nn){
		vector<int>().swap(pcoltasks[nn]);}
	PTON=0; 
}

void PInicolload(IloModel model,IloNumVarArray x){ 
	IloEnv env = model.getEnv(); 
	IloInt j,k;  
	IloNumArray taskcover(env, ITN);    
	for (j = 0; j < ITN; j++) { 
		for (k=0;k!=ITN;++k){taskcover[k]=0;}
		taskcover[j]=1;
		double thecost=10000;
		x.add(IloNumVar(PTotalcost(thecost) + PTask(taskcover)+PTask02(taskcover)));   
	}
	PN=0;
	PNN=PN;
}

double pmasterproblem (IloModel model,IloCplex lpsolver,IloNumVarArray x,int numsc) { 
	IloEnv env = model.getEnv();
	double MVAL;
	double optvalue;
	IloInt j,k;   
	IloNumArray taskcover(env, ITN);     
	try{
		for (j = PN; j < numsc; j++) {  
			for (k=0;k!=ITN;++k){taskcover[k]=0;}
			int thecol=j; 
			int thelen=pcollen[thecol];
			for (int nn=0;nn!=thelen;++nn){
				int thect=pcoltasks[thecol][nn]; 
				if (thect!=-1){ 
					taskcover[thect]=1;
				} 
			}
			double thecost=pcolcost[thecol];
			x.add(IloNumVar(PTotalcost(pcolcost[thecol])+PTask(taskcover)+PTask02(taskcover))); 
		}
		{
			lpsolver.solve();
			optvalue=PLL;
			if(lpsolver.getStatus() ==IloAlgorithm::Optimal){
				optvalue=lpsolver.getObjValue();
				for (int gg=0;gg<ITN; ++gg){
					ptaskdual[gg]=lpsolver.getDual(PTask[gg])+lpsolver.getDual(PTask02[gg]);
				}
			}
			MVAL=lpsolver.getObjValue();
		}
	}
	catch(IloException& ex){
		cerr << ex << endl;
	}
	catch(...){
		cerr << "Error..." << endl;
	}
	PN=PNN;
	return MVAL;
}

void ppathgen(int shift, int thread){ 
	double acpbd=-0.001;
	double basecost=0; 
	basecost+=C4[shift]; 
	int tfln=0; 
	vector<int> ftset; 
	vector<double> flcost (ITN); 
	vector<int> fllen(ITN); 
	vector<vector<int>> flind(ITN); 
	int LRT=BRK[shift][1]; 
	for (int nn=0;nn!=SITN[shift];++nn){
		int theind=SIS[shift][nn];  
		int thei=Iset[theind];
		int thet=Tset[theind];
		if (VIS[thei][shift]==0){
			continue;
		}
		if (thet+D[thei]<=LRT){ 
			tfln+=1;
			ftset.resize(tfln,theind);
			fllen[theind]=1;
			flind[theind].resize(1,theind);
			flcost[theind]=-ptaskdual[theind];
			if (PIID[I+1][thei]==0){ 
				flcost[theind]=PLL; 
			}
		}
		else {
			break;
		}
	}
	for (int ln=0;ln<tfln-1;++ln){
		int lind=ftset[ln]; 
		int ltask=Iset[lind];
		int ltime=Tset[lind];;
		int llen=fllen[lind];
		double lcost=flcost[lind];
		for (int fn=ln+1;fn<tfln;++fn){ 
			int find=ftset[fn];
			int ftask=Iset[find];
			int ftime=Tset[find];
			if (PIID[ltask][ftask]==0){  
				continue;
			}
			if (ltask!=ftask&&ltime+D[ltask]+Q[ltask][ftask]<=ftime){  
				if (lcost-ptaskdual[find]<flcost[find]){ 
					flcost[find]=lcost-ptaskdual[find];
					int flen=llen+1;
					fllen[find]=flen; 
					vector<int>().swap(flind[find]);
					for (int nn=0;nn!=llen;++nn){
						int temp=flind[lind][nn];
						flind[find].resize(nn+1,temp);
					}
					flind[find].resize(flen,find);
				}
			}
		}
	}
	int tbln=0; 
	vector<int> btset; 
	vector<double> blcost (ITN); 
	vector<int> bllen(ITN); 
	vector<vector<int>> blind(ITN); 
	int ERT=BRK[shift][0]; 
	for (int nn=0;nn!=SITN[shift];++nn){
		int theind=SIS[shift][nn];
		int thei=Iset[theind];
		int thet=Tset[theind];
		if (VIS[thei][shift]==0){
			continue;
		}
		int thetime=thet; 
		if (thetime<ERT+D[I]){  
			continue;  
		}
		tbln+=1;
		btset.resize(tbln,theind);
		bllen[theind]=1;
		blind[theind].resize(1,theind);
		blcost[theind]=-ptaskdual[theind];
		if (PIID[thei][I+1]==0){ 
			blcost[theind]=PLL; 
		}
	}
	for (int fn=tbln-1;fn>=1;--fn){  
		int find=btset[fn]; 
		int ftask=Iset[find];
		int ftime=Tset[find];
		int flen=bllen[find];
		double fcost=blcost[find];
		for (int ln=fn-1;ln>=0;--ln){ 
			int lind=btset[ln];
			int ltask=Iset[lind];
			int ltime=Tset[lind];
			if (PIID[ltask][ftask]==0){  
				continue;
			}
			if (ltask!=ftask&&ltime+D[ltask]+Q[ltask][ftask]<=ftime){  
				if (fcost-ptaskdual[lind]<blcost[lind]){ 
					blcost[lind]=fcost-ptaskdual[lind];
					int llen=flen+1;
					bllen[lind]=llen; 
					vector<int>().swap(blind[lind]);
					blind[lind].resize(1,lind);
					for (int nn=1;nn<llen;++nn){
						int temp=blind[find][nn-1];
						blind[lind].resize(nn+1,temp);
					}
				}
			}
		}
	}
	int seft=-1; 
	int sebt=-1;  
	double theminival=acpbd;
	for (int ln=0;ln!=tfln;++ln){
		int thelind=ftset[ln];
		int thelt=Iset[thelind];
		if (PIID[thelt][I]==0){ 
			continue;
		}
		double tempcost=basecost+flcost[thelind];
		if (theminival>tempcost){
			seft=thelind; 
			theminival=tempcost;
			sebt=-1;
		}
	}
	for (int fn=0;fn!=tbln;++fn){
		int thefind=btset[fn];
		int thebt=Iset[thefind];
		if (PIID[I][thebt]==0){
			continue;
		}
		double tempcost=basecost+blcost[thefind];
		if (theminival>tempcost){
			seft=-1;
			sebt=thefind;
			theminival=tempcost;
		}
	}
	for (int ln=0;ln!=tfln;++ln){
		int thelind=ftset[ln];
		int thelt=Iset[thelind];
		int theltime=Tset[thelind];
		if (PIID[thelt][I]==0){ 
			continue;
		}
		int lrstime=theltime+D[thelt]; 
		int ltime=theltime; 
		if (lrstime<BRK[shift][0]){
			lrstime=BRK[shift][0];
		}
		for (int fn=0;fn!=tbln;++fn){
			int thebind=btset[fn];
			int thebt=Iset[thebind];
			int theftime=Tset[thebind];
			if (PIID[I][thebt]==0){
				continue;
			}
			int brstime=theftime-D[I]; 
			if (brstime>BRK[shift][1]){
				brstime=BRK[shift][1];
			}
			if (lrstime>brstime){ 
				continue;
			}
			int ftime=theftime; 
			if (thelt!=thebt&&ltime+D[thelt]+Q[thelt][thebt]<=ftime){  
				double tempcost=basecost+flcost[thelind]+blcost[thebind];
				if (theminival>tempcost){
					theminival=tempcost;
					seft=thelind;
					sebt=thebind;
				}
			}
		}
	}
	if (theminival<acpbd){ 
		NCOLN[thread]+=1;
		prpcolshift[thread].resize(NCOLN[thread],shift);
		prpcoltasks[thread].resize(NCOLN[thread]);
		int templen=0;
		if (seft!=-1){
			for (int nn=0;nn!=fllen[seft];++nn){
				templen+=1;
				int tempind=flind[seft][nn];
				prpcoltasks[thread][NCOLN[thread]-1].resize(templen,tempind);
			}
		}
		templen+=1;
		prpcoltasks[thread][NCOLN[thread]-1].resize(templen,-1);  
		if (sebt!=-1){
			for (int nn=0;nn!=bllen[sebt];++nn){
				templen+=1;
				int tempind=blind[sebt][nn];
				prpcoltasks[thread][NCOLN[thread]-1].resize(templen,tempind);
			}
		}
		prpcollen[thread].resize(NCOLN[thread],templen);
		prpcolcost[thread].resize(NCOLN[thread],basecost);
	}
}

int pcolgen(){ 
	int newcol=0;	
	for (int nn=0;nn!=TTRD;++nn){
		vector<int>().swap(prpcolshift[nn]);
		vector<double>().swap(prpcolcost[nn]);
		for (int mm=0;mm!=NCOLN[nn];++mm){
			vector<int>().swap(prpcoltasks[nn][mm]);
		}
		vector<int>().swap(prpcollen[nn]);
		NCOLN[nn]=0;
	} 
#pragma omp parallel sections num_threads(6)
	{
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[0];++mm){
				int s=PPSset[0][mm];
				if (SITN[s]>0){
					ppathgen(s,0);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[1];++mm){
				int s=PPSset[1][mm];
				if (SITN[s]>0){
					ppathgen(s,1);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[2];++mm){
				int s=PPSset[2][mm];
				if (SITN[s]>0){
					ppathgen(s,2);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[3];++mm){
				int s=PPSset[3][mm];
				if (SITN[s]>0){
					ppathgen(s,3);}
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[4];++mm){
				int s=PPSset[4][mm];
				if (SITN[s]>0){
					ppathgen(s,4);}	
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[5];++mm){
				int s=PPSset[5][mm];
				if (SITN[s]>0){
					ppathgen(s,5);}
			}
		}									
	}
	for (int thread=0;thread!=TTRD;++thread){
		newcol+=NCOLN[thread];
		for (int mm=0;mm!=NCOLN[thread];++mm){
			PNN+=1; 
			PTON+=1; 
			int shift=prpcolshift[thread][mm];
			pcolshift.resize(PTON,shift);
			double basecost=prpcolcost[thread][mm];
			pcolcost.resize(PTON,basecost);
			int templen=prpcollen[thread][mm];
			pcollen.resize(PTON,templen);
			pcoltasks.resize(PTON);
			for (int tt=0;tt!=templen;++tt){
				int theind= prpcoltasks[thread][mm][tt];
				pcoltasks[PTON-1].resize(tt+1,theind);
			}
		}
	} 
	return newcol;
}

double pmastersolver(int create){ 
	PinputData (create);
	IloEnv env;  
	IloModel msmodel(env);
	IloCplex lpsolver(msmodel);
	lpsolver.setOut(env.getNullStream());
	lpsolver.setParam(IloCplex::Threads, 1);  
	IloNumVarArray x(env);   
	IloInt i;   
	PTotalcost = IloAdd(msmodel, IloMinimize(env));
	IloNumArray taskreach(env, ITN); 
	for (i=0;i!=ITN;++i){taskreach[i]=ITres[i];}  
	PTask = IloAdd(msmodel, IloRangeArray(env, taskreach, IloInfinity));  
	PTask02 = IloAdd(msmodel, IloRangeArray(env, -IloInfinity, taskreach));  
	PInicolload(msmodel,x);
	double lwbd;
	lwbd=pmasterproblem(msmodel,lpsolver,x,PNN);
	int ncs=pcolgen();
	while (ncs>0){
		lwbd=pmasterproblem(msmodel,lpsolver,x,PNN);
		ncs=pcolgen();
	}
	Pintsol=1;
	pnumused=0;
	vector<int>().swap(pusedcol);
	vector<double>().swap(pusedcolval);
	for (IloInt j = 0; j <PNN; j++) {  
		double trv=lpsolver.getValue(x[j+ITN]);		
		if (trv>0.0001){
			if (trv<0.99){Pintsol=0;}  
			int h=int(j); 
			pnumused+=1;
			pusedcol.resize(pnumused,h);	
			pusedcolval.resize(pnumused,trv);
		}
	}
	env.end();
	return lwbd;
}

double mastersolver(int lel, int ind, int branch, double sepe){ 
	BDN=0;
	for (int ii=0;ii!=I;++ii){
		for (int tt=0;tt!=T;++tt){
			vector<int>().swap(BDindset[ii][tt]);
			vector<double>().swap(BDset[ii][tt]);
			BDBN[ii][tt]=0;
		}
	}
	int feasi=0; 
	netload(lel,ind,branch);
	int berused[K];
	vector<vector<int>> usedbt(K); 
	double KBresult[K][B]; 
	double lwbd;
	double lwpsc;
	double uppsc;
	double thegap;
	int mintsol=1; 
	numused=0;
	vector<int>().swap(usedcol);
	while (feasi==0){
		feasi=1; 
		IloEnv env;   
		IloModel msmodel(env);
		IloCplex lpsolver(msmodel);
		lpsolver.setOut(env.getNullStream());
		lpsolver.setParam(IloCplex::Threads, 1);  
		IloNumVarArray x(env);   
		IloInt i;  
		Totalcost = IloAdd(msmodel, IloMinimize(env));
		IloNumArray vesreach(env, K); 
		for (i=0;i!=K;++i){vesreach[i]=1;} 
		Vessel = IloAdd(msmodel, IloRangeArray(env, vesreach, IloInfinity));  
		IloNumArray flheadway(env, HTN); 
		for (i=0;i!=HTN;++i){flheadway[i]=1;}  
		Hdway= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, flheadway));  
		IloNumArray bicross(env, GTN); 
		for (i=0;i!=GTN;++i){bicross[i]=1;} 
		Noncro= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, bicross));  
		IloNumArray berthtime(env, BTN);  
		for (i=0;i!=BTN;++i){berthtime[i]=1;} 
		Berocu= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, berthtime));  
		IloNumArray bendocu(env, BDN);  
		for (i=0;i!=BDN;++i){bendocu[i]=0;} 
		Bendcon= IloAdd(msmodel, IloRangeArray(env, bendocu, IloInfinity));
		IloNumArray enocu(env, 1); 
		enocu[0]=0;
		ENcon=IloAdd(msmodel, IloRangeArray(env, enocu, IloInfinity));  
		Inicolload(msmodel,x);
		lwbd=masterproblem(msmodel,lpsolver,x,NN); 
		int ncs=colgen(lel,ind,branch);
		while (ncs>0){
			lwbd=masterproblem(msmodel,lpsolver,x,NN);
			ncs=colgen(lel,ind,branch);
		}
		lwbd=ceil(lwbd-0.01);
		if (lwbd<upperbound-0.01){
			for (int k1=0;k1!=K;++k1){
				vector<int>().swap(usedbt[k1]);
				for (int b=0;b!=B;++b){
					KBresult[k1][b]=0;
				}
			}
			for (int k=0;k!=K;++k){
				berused[k]=0;
				nt1used[k]=0;
				vector<int>().swap(usedt1[k]);
				nt3used[k]=0;
				vector<int>().swap(usedt3[k]);
			}
			for (int k1=0;k1!=K;++k1){
				for (int t1=0;t1!=T;++t1){
					T1result[k1][t1]=0;
					T3result[k1][t1]=0;
				}
			}
			mintsol=1;
			for (IloInt j = 0; j <NN; j++) {
				double trv=lpsolver.getValue(x[j+1+K]);	
				if (trv>0.001){
					int h=j; 
					numused+=1;
					usedcol.resize(numused,h);	
					usedcolval.resize(numused,trv);
					int theves=colves[h]; 
					int theber=colberth[h]; 
					int tt1=coltimes[0][h];
					int tt3=coltimes[2][h];
					if (KBresult[theves][theber]==0){
						berused[theves]+=1;
						usedbt[theves].resize(berused[theves],theber);
						if (berused[theves]>1.01){mintsol=0;} 
					}
					KBresult[theves][theber]+=trv;
					if (T1result[theves][tt1]==0){
						nt1used[theves]+=1;
						usedt1[theves].resize(nt1used[theves],tt1);
						if (nt1used[theves]>1.01){mintsol=0;} 
					}
					T1result[theves][tt1]+=trv;
					if (T3result[theves][tt3]==0){
						nt3used[theves]+=1;
						usedt3[theves].resize(nt3used[theves],tt3);
						if (nt3used[theves]>1.01){mintsol=0;} 
					}
					T3result[theves][tt3]+=trv;
				}
			}
			lwpsc=lpsolver.getValue(x[0]); 
			uppsc=pmastersolver(1);
			thegap=100*(uppsc-lwpsc)/double(lwbd);
			if (thegap>sepe){
				feasi=0; 
				for (int nn=0;nn!=ITN;++nn){
					int thei=Iset[nn];
					int thet=Tset[nn];
					double thedual=ptaskdual[nn];
					BDBN[thei][thet]+=1;
					BDindset[thei][thet].resize(BDBN[thei][thet],BDN);
					BDset[thei][thet].resize(BDBN[thei][thet],thedual);
				}
				BDN+=1; 
				TBDN+=1; 
			}
		}
		env.end();
		t_crt=clock();
		if (t_crt-t_start>=uptime*1000){
			cout<<"Time limit reached"<<endl;
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			if (lel>-1){
				if (lwbd<lowerbound[lel][ind]-0.001){
					lwbd=lowerbound[lel][ind];
				}}
			break;
		}
	}
	if (lwbd<upperbound-0.01){
		int thetype=-1;
		int then1=-1;
		int then2=-1;
		double minscore=0.49;
		double tempd=0;
		if (mintsol==0){
			for (int kk=0;kk!=K;++kk){
				if (berused[kk]>=2){
					for (int nn=0;nn!=berused[kk];++nn){
						int tempber=usedbt[kk][nn];
						double trv=KBresult[kk][tempber];
						if (trv>=0.5){
							tempd=trv-0.5;}
						else {
							tempd=0.5-trv;}
						if (minscore>tempd){ 
							minscore=tempd;
							thetype=1;
							then1=kk;
							then2=tempber;
						}
						if (minscore<0.001){
							break;
						}
					}
				}
				if (minscore<0.001){
					break;
				}
			}
			if (thetype==-1){
				for (int kk=0;kk!=K;++kk){
					if (nt1used[kk]>=2){
						for (int nn=0;nn!=nt1used[kk];++nn){
							int tempt1=usedt1[kk][nn];
							double trv=T1result[kk][tempt1];
							if (trv>=0.5){
								tempd=trv-0.5;}
							else {
								tempd=0.5-trv;}
							if (minscore>tempd){
								minscore=tempd;
								thetype=2;
								then1=kk;
								then2=tempt1;
							}
							if (minscore<0.001){
								break;
							}
						}
					}
					if (minscore<0.001){
						break;
					}
				}
			}
			if (thetype==-1){
				for (int kk=0;kk!=K;++kk){
					if (nt3used[kk]>=2){
						for (int nn=0;nn!=nt3used[kk];++nn){
							int tempt3=usedt3[kk][nn];
							double trv=T3result[kk][tempt3];
							if (trv>=0.5){
								tempd=trv-0.5;}
							else {
								tempd=0.5-trv;}
							if (minscore>tempd){ 
								minscore=tempd;
								thetype=2; 
								then1=kk+K;
								then2=tempt3;
							}
							if (minscore<0.001){
								break;
							}
						}
					}
					if (minscore<0.001){
						break;
					}
				}
			}
		}
		if (Pintsol==0){ 
			Pintsol=1;
			if (thetype==-1){ 
				double ISresult[I][S]; 
				int shiftused[I];
				vector<vector<int>> usedshift(I);  
				for (int k=0;k!=I;++k){
					shiftused[k]=0;
				}
				for (int i=0;i!=I;++i){
					for (int s=0;s!=S;++s){
						ISresult[i][s]=0;
					}
				}
				for (int nn=0; nn!=pnumused;nn++){
					double trv=pusedcolval[nn];	
					int h=pusedcol[nn];
					int theshift=pcolshift[h]; 
					int thelen=pcollen[h]; 
					for (int nn=0;nn!=thelen;++nn){
						int theind=pcoltasks[h][nn];
						if (theind!=-1){
							int thect=Iset[theind];
							if (ISresult[thect][theshift]==0){
								shiftused[thect]+=1;
								usedshift[thect].resize(shiftused[thect],theshift);
							}
							ISresult[thect][theshift]+=trv;
						}
					}
				}
				for (int kk=0;kk!=I;++kk){
					if (shiftused[kk]>=2){
						Pintsol=0;
						for (int nn=0;nn!=shiftused[kk];++nn){
							int temp=usedshift[kk][nn]; 
							double trv=ISresult[kk][temp];
							if (trv>=0.5){
								tempd=trv-0.5;}
							else {
								tempd=0.5-trv;}
							if (minscore>tempd){ 
								minscore=tempd;
								thetype=3; 
								then1=kk; 
								then2=temp; 
							}
							if (minscore<0.001){
								break;
							}
						}
					}
					if (minscore<0.001){
						break;
					}
				}
			}
			if (thetype==-1){ 
				double IIresult[I+2][I+2]; 	
				int followers[I];
				vector<vector<int>> usedflw(I); 
				for (int i=0;i!=I+2;++i){
					for (int j=0;j!=I+2;++j){
						IIresult[i][j]=0;
					}
				}
				for (int k=0;k!=I;++k){
					followers[k]=0;
				}
				for (int nn = 0; nn !=pnumused; nn++) {
					double trv=pusedcolval[nn];	
					int h=pusedcol[nn]; 
					int thelen=pcollen[h];
					int thelt=I+1; 
					for (int nn=0;nn!=thelen;++nn){
						int theind=pcoltasks[h][nn]; 
						int thect;
						if (theind!=-1){
							thect=Iset[theind];} 
						else{
							thect=I;  
						}
						if (thelt<I){
							if (IIresult[thelt][thect]==0){
								followers[thelt]+=1;
								usedflw[thelt].resize(followers[thelt],thect);
								if (followers[thelt]>1.01){
									Pintsol=0;
								}
							}
							IIresult[thelt][thect]+=trv;
						}
						thelt=thect;
					}
					if (thelt<I){
						if (IIresult[thelt][I+1]==0){
							followers[thelt]+=1;
							usedflw[thelt].resize(followers[thelt],I+1);
						}
						IIresult[thelt][I+1]+=trv;
					}
				}
				for (int kk=0;kk!=I;++kk){
					if (followers[kk]>=2){
						for (int nn=0;nn!=followers[kk];++nn){
							int temp=usedflw[kk][nn];
							double trv=IIresult[kk][temp];
							if (trv>=0.5){
								tempd=trv-0.5;}
							else {
								tempd=0.5-trv;}
							if (minscore>tempd){
								minscore=tempd;
								thetype=4;
								then1=kk; 
								then2=temp;
							}
							if (minscore<0.001){
								break;
							}
						}
					}
					if (minscore<0.001){
						break;
					}
				}
			}
		}
		if (mintsol!=1 || Pintsol!=1){ 
			int crtlel=lel+1;
			if (crtlel+1>levels){ 
				levels+=1;
				nodenum.resize(levels,0);   
				nodeindx.resize(levels);
				lowerbound.resize(levels);
				brcho[0].resize(levels);
				brcho[1].resize(levels);
				brtype.resize(levels);
				brnd1.resize(levels);
				brnd2.resize(levels);
			}
			nodenum[crtlel]+=1;
			int lenum=nodenum[crtlel];
			nodeindx[crtlel].resize(lenum);
			nodeindx[crtlel][lenum-1].resize(1,ind);
			nodeindx[crtlel][lenum-1].resize(2,branch); 
			lowerbound[crtlel].resize(lenum,lwbd);
			brcho[0][crtlel].resize(lenum,1);
			brcho[1][crtlel].resize(lenum,1);
			brtype[crtlel].resize(lenum,thetype);
			brnd1[crtlel].resize(lenum,then1);
			brnd2[crtlel].resize(lenum,then2);
		}
		if (mintsol==1 && Pintsol==1){ 
			if (lwbd-lwpsc+uppsc<upperbound){
				upperbound=lwbd-lwpsc+uppsc;
				cout<<"a new upper bound is found by branching"<<upperbound<<endl;}
		}
	}
	return lwbd;
}

void nodebranch(){ 
	int fnode;              
	int flayer;              
	double sepe=0.01;
	while(1){
		totallb=upperbound;
		int tnn=0; 
		vector<int> opennd; 
		vector<int> openlv;   
		for (int ll=0;ll!=levels;++ll){
			int tndn=nodenum[ll];
			for (int nn=0;nn!=tndn;++nn){
				double thelb=lowerbound[ll][nn];
				if (thelb<upperbound-0.001){
					if (brcho[0][ll][nn]==0 && brcho[1][ll][nn]==0){ 
						lowerbound[ll][nn]=LL;
					}
					else {
						tnn+=1;
						openlv.resize(tnn,ll);
						opennd.resize(tnn,nn);
						if (thelb<totallb){
							totallb=thelb;
						}
					}	
				}
			}
		}
		totalgap=100*(upperbound-totallb)/totallb;
		cout << "the optimality gap is:"<<totalgap<<"%"<<endl;
		t_crt=clock();
		if (totalgap<=totalerr){
			cout<<"optimality gap reached"<<endl;
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			break;
		}
		if (t_crt-t_start>=uptime*1000){
			cout<<"Time limit reached"<<endl;
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			break;
		}
		if (tnn==0){
			cout<<"all nodes have been closed"<<endl;
			t_crt=clock();
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			break;
		}
		double thelb=LL-10;
		if (tnn>0){ 
			flayer=-10;
			fnode=-10; 
			for (int mm=0;mm!=tnn;++mm){
				int templv=openlv[mm];
				int tempnd=opennd[mm];
				if (brcho[0][templv][tempnd]==1 || brcho[1][templv][tempnd]==1){
					double templb=lowerbound[templv][tempnd];
					if (thelb>templb){
						thelb=templb;
						flayer=templv;
						fnode=tempnd;
					}
				}
				if (thelb==totallb){
					break;
				}
			}
			if (fnode!=-10){ 
				if (brcho[0][flayer][fnode]==1){
					brcho[0][flayer][fnode]=0;
					cout<<"0-branch on node["<<flayer<<"]["<<fnode<<"]"<<endl;
					mastersolver (flayer,fnode,0,sepe);	}
				if (brcho[1][flayer][fnode]==1){
					brcho[1][flayer][fnode]=0;
					cout<<"1-branch on node["<<flayer<<"]["<<fnode<<"]"<<endl;
					mastersolver (flayer,fnode,1,sepe); }
			}
		}
	}
	cout << endl;
	cout << endl;
	cout << "the final optimality gap is:"<<totalgap<<"%"<<endl;
	cout << endl;
}

void solvebap(){
	inputData();
	mastersolver(-1,-1,-1,0.01);
	nodebranch();
}

void reswrite(){
	cout <<"CPU time:"<<double(t_end-t_start)/double(1000)<<endl;
	cout <<"Upper bound:"<<upperbound<<endl;
	cout <<"Gap:"<<totalgap<<endl;
}

int main (int argc, char **argv) {
	t_start=clock();
	cout << "formulation" << endl;
	solvebap();
	t_end =clock();
	reswrite();
	cout << "succeeded" << endl;
	return 0;
}
