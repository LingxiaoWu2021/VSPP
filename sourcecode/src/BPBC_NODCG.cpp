#include <ilcplex/ilocplex.h>   /* cplex */
#include <time.h>               /* time */      
#include <vector>              
#include <omp.h>               /* parallel */
#include "Selfmath.h"

namespace patch {template < typename T > std::string to_string( const T& n ){std::ostringstream stm; stm << n; return stm.str() ;}}

using namespace std;
////////////////////////////////////////////////////////
//                                                    //
// Source CPP Code for the BPBC Algorithm without Dynamic Constraint Generation
// Vessel Service Planning in Seaports, Operations Research
//                                                  
// Authors: Lingxiao Wu, Yossiri Adulyasak, Jean-François Cordeau, Shuaian Wang
///////////////////////////////////////////////////////

//input data starts here

extern const int S = 6;
extern const int K =10;
extern const int T = 288;
extern const int B = 10;
extern const int I = 20;
extern const int NCPN = 0;
extern const int HWPN = 180;
int BRT[B]={0,14,0,21,6,47,20,0,22,44};
int Chaocu[B]={-1,-1,-1,-1,-1,-1,-1,-1,-1,51};
int HDT[B]={-1,15,-1,22,7,48,21,-1,23,45};
int E[I][2]={{0,39},{0,28},{23,71},{29,77},{38,86},{62,110},{87,135},{93,141},{101,149},{140,188},{59,107},{71,119},{83,131},{145,193},{150,198},{133,181},{160,208},{161,209},{174,222},{216,264}};
int BRK[S][2]={{14,34},{62,82},{110,130},{158,178},{206,226},{254,274}};
int VLL[K]={0,0,0,2,1,1,0,0,0,0};
int F[I][I]={{0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0}};
int D[I+1]={7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,6};
int H[K][B]={{52,52,52,52,52,52,52,52,52,52},{64,64,64,64,64,64,64,64,64,64},{53,53,53,53,53,53,53,53,53,53},{109,109,109,109,109,109,109,109,109,109},{105,105,105,105,105,105,105,105,105,105},{64,64,64,64,64,64,64,64,64,64},{66,66,66,66,66,66,66,66,66,66},{61,61,61,61,61,61,61,61,61,61},{66,66,66,66,66,66,66,66,66,66},{69,69,69,69,69,69,69,69,69,69}};
int Q[I+1][I+1]={{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};
int ST[S][2]={{0,47},{48,95},{96,143},{144,191},{192,239},{240,287}};
int C1[K]={50000,50000,50000,50000,50000,50000,50000,50000,50000,50000};
int C2[I][T]={{0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,524,526,528,530,532,534,536,538,540,542,544,546,548,550,552,554,556,558,560,562,564,566,568,570,572,574},{0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,524,526,528,530,532,534,536,538,540,542,544,546,548,550,552,554,556,558,560,562,564,566,568,570,572,574},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,524,526,528},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138,144,150,156,162,168,174,180,186,192,198,204,210,216,222,228,234,240,246,252,258,264,270,276,282,288,294,300,306,312,318,324,330,336,342,348,354,360,366,372,378,384,390,396,402,408,414,420,426,432,438,444,450,456,462,468,474,480,486,492,498,504,510,516,522,528,534,540,546,552,558,564,570,576,582,588,594,600,606,612,618,624,630,636,642,648,654,660,666,672,678,684,690,696,702,708,714,720,726,732,738,744,750,756,762,768,774,780,786,792,798,804,810,816,822,828,834,840,846,852,858,864,870,876,882,888,894,900,906,912,918,924,930,936,942,948,954,960,966,972,978,984,990,996,1002,1008,1014,1020,1026,1032,1038,1044,1050,1056,1062,1068,1074,1080,1086,1092,1098,1104,1110,1116,1122,1128,1134,1140,1146,1152,1158,1164,1170,1176,1182,1188,1194,1200,1206,1212,1218,1224,1230,1236,1242,1248,1254,1260,1266,1272,1278,1284,1290,1296,1302,1308,1314,1320,1326,1332,1338,1344,1350,1356,1362,1368,1374,1380,1386,1392,1398,1404,1410,1416,1422,1428,1434,1440,1446,1452,1458,1464,1470,1476,1482,1488,1494,1500,1506,1512,1518,1524,1530,1536,1542,1548},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864,868,872,876,880,884,888,892,896,900,904,908,912,916,920,924,928,932,936,940,944,948,952,956,960,964,968,972,976,980,984,988,992,996},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99,102,105,108,111,114,117,120,123,126,129,132,135,138,141,144,147,150,153,156,159,162,165,168,171,174,177,180,183,186,189,192,195,198,201,204,207,210,213,216,219,222,225,228,231,234,237,240,243,246,249,252,255,258,261,264,267,270,273,276,279,282,285,288,291,294,297,300,303,306,309,312,315,318,321,324,327,330,333,336,339,342,345,348,351,354,357,360,363,366,369,372,375,378,381,384,387,390,393,396,399,402,405,408,411,414,417,420,423,426,429,432,435,438,441,444,447,450,453,456,459,462,465,468,471,474,477,480,483,486,489,492,495,498,501,504,507,510,513,516,519,522,525,528,531,534,537,540,543,546,549,552,555,558,561,564,567,570,573,576,579,582,585,588,591,594,597,600,603,606,609,612,615,618,621,624,627,630,633,636,639,642,645,648,651,654,657,660,663,666,669,672,675},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864,868,872,876,880,884,888,892,896,900,904,908,912},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,24,36,48,60,72,84,96,108,120,132,144,156,168,180,192,204,216,228,240,252,264,276,288,300,312,324,336,348,360,372,384,396,408,420,432,444,456,468,480,492,504,516,528,540,552,564,576,588,600,612,624,636,648,660,672,684,696,708,720,732,744,756,768,780,792,804,816,828,840,852,864,876,888,900,912,924,936,948,960,972,984,996,1008,1020,1032,1044,1056,1068,1080,1092,1104,1116,1128,1140,1152,1164,1176,1188,1200,1212,1224,1236,1248,1260,1272,1284,1296,1308,1320,1332,1344,1356,1368,1380,1392,1404,1416,1428,1440,1452,1464,1476,1488,1500,1512,1524,1536,1548,1560,1572,1584,1596,1608,1620,1632,1644,1656,1668,1680,1692,1704},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136,144,152,160,168,176,184,192,200,208,216,224,232,240,248,256,264,272,280,288,296,304,312,320,328,336,344,352,360,368,376,384,392,400,408,416,424,432,440,448,456,464,472,480,488,496,504,512,520,528,536,544,552,560,568,576,584,592,600,608,616,624,632,640,648,656,664,672,680,688,696,704,712,720,728,736,744,752,760,768,776,784,792,800,808,816,824,832,840,848,856,864,872,880,888,896,904,912,920,928,936,944,952,960,968,976,984,992,1000,1008,1016,1024,1032,1040,1048,1056,1064,1072,1080,1088,1096},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138,144,150,156,162,168,174,180,186,192,198,204,210,216,222,228,234,240,246,252,258,264,270,276,282,288,294,300,306,312,318,324,330,336,342,348,354,360,366,372,378,384,390,396,402,408,414,420,426,432,438,444,450,456,462,468,474,480,486,492,498,504,510,516,522,528,534,540,546,552,558,564,570,576,582,588,594,600,606,612,618,624,630,636,642,648,654,660,666,672,678,684,690,696,702,708,714,720,726,732,738,744,750,756,762,768,774,780,786,792,798,804,810,816,822,828,834,840,846,852,858,864,870,876,882,888,894,900,906,912,918,924},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284}};
int C3[K][B]={{330,260,309,356,382,302,263,348,354,333},{442,371,352,438,461,454,378,320,323,416},{337,310,352,371,334,299,315,268,376,305},{703,676,719,600,621,779,807,692,627,545},{557,698,693,588,662,761,704,557,588,751},{336,355,336,467,326,403,406,400,454,339},{429,469,399,393,403,333,416,403,416,379},{375,345,345,448,305,381,378,308,323,393},{330,439,469,393,353,360,442,406,406,347},{466,469,414,373,449,490,480,421,500,511}};
int C4[S]={48,48,48,48,48,48};
int ODS[2][1]={{},{}};
int Hset[2][HWPN]={{0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19},{1,2,3,4,5,6,7,8,9,0,2,3,4,5,6,7,8,9,0,1,3,4,5,6,7,8,9,0,1,2,4,5,6,7,8,9,0,1,2,3,5,6,7,8,9,0,1,2,3,4,6,7,8,9,0,1,2,3,4,5,7,8,9,0,1,2,3,4,5,6,8,9,0,1,2,3,4,5,6,7,9,0,1,2,3,4,5,6,7,8,11,12,13,14,15,16,17,18,19,10,12,13,14,15,16,17,18,19,10,11,13,14,15,16,17,18,19,10,11,12,14,15,16,17,18,19,10,11,12,13,15,16,17,18,19,10,11,12,13,14,16,17,18,19,10,11,12,13,14,15,17,18,19,10,11,12,13,14,15,16,18,19,10,11,12,13,14,15,16,17,19,10,11,12,13,14,15,16,17,18}};

//input data ends here

double uptime=3600; 
double totalerr=0.00001;

int BTN=0; 
int BTindex[B][T];
int GTN=0;
int GTindex[NCPN+1][T];
int HTN=0; 
int HTindex[HWPN][T];

int TSdn[T]; 
vector<vector<int>> TSdex(T);

int LL=999999;
int PLL=999999;

int levels=0; 
double upperbound;
double totallb; 
double	pupperbound=PLL;
double	ptotallb=-PLL;
double totalgap; 
vector<int> nodenum;  
vector<vector<vector<int>>> nodeindx;   
vector<vector<double>> lowerbound;   
vector<vector<vector<int>>> brcho(2);   
vector<vector<int>> brtype; 
vector<vector<int>> brnd1;
vector<vector<int>> brnd2;  
vector<vector<vector<int>>> bendcutnode(2);   
vector<vector<int>> fxn;
vector<vector<vector<int>>> fxves;
vector<vector<vector<int>>> fxberth; 

int bclevels=1; 
vector<int> bcnodenum;
vector<vector<int>>bcnodeindx;  
vector<vector<int>>bccn;  
vector<vector<vector<int>>>bccset; 

int N; 
int NN;
int TON;
int PN; 
int PNN; 
int PTON; 

vector <int> colves;   
vector <int> colberth;  
vector <double> colcost;  
vector<vector<int>> coltimes(3); 
vector<vector<int>> colshifts(2);  
vector <int> pcolshift; 
vector <double> pcolcost;  
vector<int> pcollen;  
vector<vector<int>> pcoltasks;

int numused=0;
vector<int> usedcol;
vector<double> usedcolval;
int pnumused=0;
vector<int> pusedcol;
vector<double> pusedcolval;

ILOSTLBEGIN 
IloObjective   Totalcost;
IloRangeArray  Vessel;
IloRangeArray  Berocu;
IloRangeArray  Hdway;
IloRangeArray  Noncro;
IloRangeArray  Bendcon; 
IloRangeArray  PSRcon; 
IloRangeArray  ENcon;

IloObjective   PTotalcost;
IloRangeArray  PTask;
IloRangeArray  PTask02; 
double vesdual [K];
vector<double> berocudual;
vector<double> hdwaydual;
vector<double> noncrodual;
vector<double> bdsdual;
vector<double> srtdual; 
vector<double> ptaskdual; 

int SITN[S]; 
vector<vector<int>> SIS(S); 
int nt1used[K];
int nt3used[K]; 
vector<vector<int>> usedt1(K); 
vector<vector<int>> usedt3(K);

int BSEQ[K][B]; 
double T1result[K][T];
double T3result[K][T];
int ITN=0; 
int Iset[I*T];
int Tset[I*T];
vector<double> ITres;

int BDN=0; 
int BDBN[I][T]; 
vector<vector<vector<int>>> BDindset(I);  
vector<vector<vector<double>>> BDset(I);
vector<int> BDCaddable; 

int SRTN=0;
int SRTindex[S][T];
int MQ[I][S][T]; 

int VKB[K][B]; 
int VIS[I][S];
int VIT[I][T]; 
int OVIT[I][T]; 
int PIID[I+2][I+2];
int Pintsol=0; 

extern const int TTRD=6;
int PRTN[TTRD];
vector<vector<int>> PVset(TTRD);
vector<vector<int>> PBset(TTRD);
int NCOLN[TTRD];
vector <vector <int>> prcolves(TTRD);   
vector <vector <int>> prcolberth(TTRD);   
vector <vector <double>> prcolcost(TTRD);   
vector <vector<vector<int>>> prcoltimes(TTRD); 
vector <vector<vector<int>>> prcolshifts(TTRD); 

int PPRTN[TTRD];
vector<vector<int>> PPSset(TTRD);
vector <vector <int>> prpcolshift(TTRD);  
vector <vector <double>> prpcolcost(TTRD); 
vector <vector<int>> prpcollen(TTRD);   
vector <vector<vector<int>>> prpcoltasks(TTRD); 

clock_t t_start,t_end,t_crt; 
double CRTLB=0;
double BVBD[B][K];

void PRLsetup(){
	for (int tt=0;tt!=TTRD;++tt){
		PRTN[tt]=0;
		prcoltimes[tt].resize(3);
		prcolshifts[tt].resize(2);
		PPRTN[tt]=0;
	}
	int basen=floor(double(K*B)/double(TTRD));
	for (int nn=0;nn!=TTRD;++nn){
		PRTN[nn]=basen;
	}
	int leftn=K*B-basen*TTRD;
	for (int nn=0;nn!=leftn;++nn){
		PRTN[nn]+=1;
	}
	int thetd=0;
	int theno=0;
	for (int k=0;k!=K;++k){
		for (int b=0;b!=B;++b){	
			PVset[thetd].resize(theno+1,k);
			PBset[thetd].resize(theno+1,b);
			theno+=1;
			if (theno>=PRTN[thetd]){
				thetd+=1;
				theno=0;
			}
		}	
	}
	basen=floor(double(S)/double(TTRD));
	for (int nn=0;nn!=TTRD;++nn){
		PPRTN[nn]=basen;
	}
	leftn=S-basen*TTRD;
	for (int nn=0;nn!=leftn;++nn){
		PPRTN[nn]+=1;
	}
	thetd=0;
	theno=0;
	for (int s=0;s!=S;++s){
		PPSset[thetd].resize(theno+1,s);
		theno+=1;
		if (theno>=PPRTN[thetd]){
			thetd+=1;
			theno=0;
		}
	}	
}

void CGsetup(){ 
	for (int i=0;i!=I;++i){
		BDindset[i].resize(T);
		BDset[i].resize(T);
	}
	for (int i=0;i!=I;++i){
		for (int t=0;t!=T;++t){
			BDBN[i][t]=0;
		}
	}
	for (int b=0;b!=B;++b){
		for (int t=0;t!=T;++t){
			BTindex[b][t]=BTN;
			BTN+=1;
		}
	}
	for (int s=0;s!=S;++s){
		for (int t=ST[s][0];t<=ST[s][1];++t){
			TSdn[t]=0;
		}
	}
	for (int s=0;s!=S;++s){
		for (int t=ST[s][0];t<=ST[s][1];++t){
			TSdn[t]+=1; 
			TSdex[t].resize(TSdn[t],s);
		}
	}
	for (int s=0;s!=S;++s){
		for (int t=ST[s][0];t<=ST[s][1];++t){
			SRTindex[s][t]=SRTN;
			SRTN+=1;}
	}
	int OTSRN[S]; 
	vector<vector<int>> OTSRset(S);
	int SRIRCD[S][I];  
	for (int s=0;s!=S;++s){
		for (int i=0;i!=I;++i){
			SRIRCD[s][i]=0;
		}
	}
	for (int s=0;s!=S;++s){
		OTSRN[s]=0;
	}
	for (int k=0;k!=K;++k){ 
		int thei=k;
		for (int t=E[thei][0];t<=E[thei][1];++t){
			for (int n=0;n!=TSdn[t];++n){
				int thes=TSdex[t][n]; 
				if (SRIRCD[thes][thei]==0){
					SRIRCD[thes][thei]=1;
					OTSRN[thes]+=1;
					OTSRset[thes].resize(OTSRN[thes],thei);}
			}
		}
		thei=k+K; 
		for (int t=E[thei][0];t<=E[thei][1];++t){
			for (int n=0;n!=TSdn[t];++n){
				int thes=TSdex[t][n];
				if (SRIRCD[thes][thei]==0){
					SRIRCD[thes][thei]=1;
					OTSRN[thes]+=1;
					OTSRset[thes].resize(OTSRN[thes],thei);}
			}
		}
	}
	for (int s=0;s!=S;++s){
		for (int i=0;i!=I;++i){
			for (int t=ST[s][0];t<=ST[s][1];++t){
				MQ[i][s][t]=T;}
		}
	}
	for (int s=0;s!=S;++s){
		for (int n=0;n!=OTSRN[s];++n){
			int thei=OTSRset[s][n];
			int esti=E[thei][0];
			if (esti<ST[s][0]){
				esti=ST[s][0];
			}
			int lsti=E[thei][1];
			if (lsti>ST[s][1]){
				lsti=ST[s][1];
			}
			for (int t=esti;t<=lsti;++t){
				for (int m=0;m!=OTSRN[s];++m){
					if (n==m){continue;}
					int thej=OTSRset[s][m];
					int lstj=E[thej][1];
					if  (lstj>ST[s][1]){
						lstj=ST[s][1];
					}
					if (t+D[thei]+Q[thei][thej]<=lstj){ 
						int tetime=t+D[thei]+Q[thei][thej];  
						if (tetime<E[thej][0]){ 
							tetime=E[thej][0];
						}
						if (MQ[thei][s][t]>tetime-(t+D[thei])){
							MQ[thei][s][t]=tetime-(t+D[thei]); 
						}
					}
				}
			}
		}
	}
	for (int i=0;i!=I;++i){
		for (int t=E[i][0];t<=E[i][1];++t){
			OVIT[i][t]=1;
		}
	}    
	for (int i=K;i!=2*K;++i){
		for (int b=0;b!=B;++b){
			int timet=BRT[b];
			int edtime=HDT[b];  
			if (HDT[b]!=-1){
				for (int tt=timet;tt<edtime;++tt){
					OVIT[i][tt]=0;}}
		}
	}
	for (int i=0;i!=K;++i){
		if (VLL[i]>=2){
			for (int b=0;b!=B;++b){
				int time02=Chaocu[b];
				if (time02!=-1){
					int timet=BRT[b];
					for (int t=timet;t<=time02-1;++t){
						OVIT[i][t]=0;
					}
				}
			}
		}
	}
	for (int i=0;i!=I;++i){
		for (int t=E[i][0];t<=E[i][1];++t){
			int doable=0;
			for (int n=0;n!=TSdn[t];++n){
				int thes=TSdex[t][n];
				if (BRK[thes][0]+D[I]<=t){
					doable=1;
					break;
				}
				if (t+D[i]<=BRK[thes][1]){
					doable=1;
					break;
				}
			}
			OVIT[i][t]=doable;
		}
	}
	for (int n=0;n!=HWPN;++n){ 
		for (int t=0;t!=T;++t){
			HTindex[n][t]=HTN;
			HTN+=1;  
		}
	}
	for (int n=0;n!=NCPN;++n){
		for (int t=0;t!=T;++t){
			GTindex[n][t]=GTN;
			GTN+=1;
		}
	}
	noncrodual.resize(GTN);
	hdwaydual.resize(HTN);
	berocudual.resize(BTN);
}

void inputData (){
	PRLsetup();
	CGsetup();
	upperbound=LL;
	totallb=-LL;
	for (int k=0;k!=K;++k){
		double BScost[B];
		for (int b=0;b!=B;++b){
			BScost[b]=C3[k][b];
		}
		for (int b=0;b!=B;++b){
			int theb=mathmin03(BScost,B);
			BSEQ[k][b]=theb;
			BScost[theb]=999999;
		}
	}
	bcnodenum.resize(1,1); 
	bcnodeindx.resize(1);
	bcnodeindx[0].resize(1,-1);
	bccn.resize(1);
	bccn[0].resize(1,0);
	bccset.resize(1);
	bccset[0].resize(1);
}

void Inicolload(IloModel model,IloNumVarArray x){ 
	IloEnv env = model.getEnv(); 
	IloInt s,i,j,t,k;   
	IloNumArray vescover(env, K);     
	IloNumArray berocu(env,BTN);    
	IloNumArray headway(env, HTN);
	IloNumArray noncro(env, GTN);    
	IloNumArray bencro(env, BDN);     
	IloNumArray psrcro(env, SRTN);    
	IloNumArray encro(env, 1);     
	{  
		for (k=0;k!=K;++k){vescover[k]=0;}
		for (i=0;i!=BTN;++i){berocu[i]=0;}
		for (i=0;i!=HTN;++i){headway[i]=0;}
		for (i=0;i!=GTN;++i){noncro[i]=0;}
		for (i=0;i!=BDN;++i){bencro[i]=1;}
		for (i=0;i!=SRTN;++i){psrcro[i]=0;}
		encro[0]=1;
		x.add(IloNumVar(Totalcost(1) + Vessel(vescover)+Berocu(berocu)+Hdway(headway)+Noncro(noncro)+Bendcon(bencro)+PSRcon(psrcro)+ENcon(encro)));   
	}
	{  
		for (s=0;s!=S;++s){
			for (k=0;k!=K;++k){vescover[k]=0;}
			for (i=0;i!=BTN;++i){berocu[i]=0;}
			for (i=0;i!=HTN;++i){headway[i]=0;}
			for (i=0;i!=GTN;++i){noncro[i]=0;}
			for (i=0;i!=BDN;++i){bencro[i]=0;}
			for (i=0;i!=SRTN;++i){psrcro[i]=0;}
			encro[0]=-C4[s];
			for (t=ST[s][0];t<=ST[s][1];++t){
				int theind=SRTindex[s][t];
				psrcro[theind]=1;}
			x.add(IloNumVar(Totalcost(0) + Vessel(vescover)+Berocu(berocu)+ Hdway(headway)+Noncro(noncro)+Bendcon(bencro)+PSRcon(psrcro)+ENcon(encro)));
		}
	}
	for (j = 0; j < K; j++) {  
		for (k=0;k!=K;++k){vescover[k]=0;}
		for (i=0;i!=BTN;++i){berocu[i]=0;}
		for (i=0;i!=HTN;++i){headway[i]=0;}
		for (i=0;i!=GTN;++i){noncro[i]=0;}
		for (i=0;i!=BDN;++i){bencro[i]=0;}
		for (i=0;i!=SRTN;++i){psrcro[i]=0;}
		encro[0]=0;
		vescover[j]=1;
		x.add(IloNumVar(Totalcost(C1[j]) + Vessel(vescover)+Berocu(berocu)+ Hdway(headway)+Noncro(noncro)+Bendcon(bencro)+PSRcon(psrcro)+ENcon(encro)));   
	}
	N=0; 
	NN=N; 
	TON=0; 
	vector <int> hhcolves;  
	vector <int> hhcolberth;  
	vector <double> hhcolcost;   
	vector<vector<int>> hhcoltimes(3);  
	vector<vector<int>> hhcolshifts(2);  
	if (numused>0){
		for (int nn=0;nn!=numused;++nn){
			int thecol=usedcol[nn];
			int theves=colves[thecol];
			int theber=colberth[thecol];
			double thecost=colcost[thecol];
			int thet1=coltimes[0][thecol];
			int thet2=coltimes[1][thecol]; 
			int thet3=coltimes[2][thecol]; 
			int thes1=colshifts[0][thecol];
			int thes3=colshifts[1][thecol];
			TON+=1; 
			hhcolves.resize(TON,theves);
			hhcolberth.resize(TON,theber);
			hhcolcost.resize(TON,thecost);
			hhcoltimes[0].resize(TON,thet1);
			hhcoltimes[1].resize(TON,thet2);
			hhcoltimes[2].resize(TON,thet3);
			hhcolshifts[0].resize(TON,thes1);
			hhcolshifts[1].resize(TON,thes3);
			NN+=1;
		}
	}
	colves.swap(hhcolves);
	vector<int>().swap(hhcolves);
	colberth.swap(hhcolberth);
	vector<int>().swap(hhcolberth);
	colcost.swap(hhcolcost);
	vector<double>().swap(hhcolcost);
	for (int nn=0;nn!=3;++nn){ 
		coltimes[nn].swap(hhcoltimes[nn]);
		vector<int>().swap(hhcoltimes[nn]);
	}
	for (int nn=0;nn!=2;++nn){
		colshifts[nn].swap(hhcolshifts[nn]);
		vector<int>().swap(hhcolshifts[nn]);
	}
	numused=0;
	vector<int>().swap(usedcol);
	vescover.end();
	berocu.end();
	headway.end();
	noncro.end();
	bencro.end();
	psrcro.end();
	encro.end();
}

double masterproblem (IloModel model,IloCplex lpsolver,IloNumVarArray x,int numsc) {
	IloEnv env = model.getEnv();
	double MVAL;
	double optvalue;
	IloInt j,k,i,t,t1; 
	IloNumArray vescover(env, K);    
	IloNumArray berocu(env,BTN);     
	IloNumArray headway(env, HTN);
	IloNumArray noncro(env, GTN);    
	IloNumArray bencro(env, BDN);    
	IloNumArray psrcro(env, SRTN);    
	IloNumArray encro(env, 1);     
	try{
		for (j = N; j < numsc; j++) {  
			int thecol=j; 
			for (k=0;k!=K;++k){vescover[k]=0;}
			for (i=0;i!=BTN;++i){berocu[i]=0;}
			for (i=0;i!=HTN;++i){headway[i]=0;}
			for (i=0;i!=GTN;++i){noncro[i]=0;}
			for (i=0;i!=BDN;++i){bencro[i]=0;}
			for (i=0;i!=SRTN;++i){psrcro[i]=0;}
			encro[0]=0;
			int theves=colves[thecol];
			vescover[theves]=1;
			int thet1=coltimes[0][thecol]; 
			int thet3=coltimes[2][thecol];
			for (int n=0;n!=HWPN;++n){
				int thei=Hset[0][n];
				int thej=Hset[1][n];
				if (theves==thei){
					int et1=thet1+F[theves][thej]-1;  
					if (et1>T-1){et1=T-1;}
					for (t1=thet1;t1<=et1;++t1){
						int theind=HTindex[n][t1]; 
						headway[theind]=1;
					}
				}
				if (theves==thej){ 
					int theind=HTindex[n][thet1]; 
					headway[theind]=1;
				}
				if (theves+K==thei){
					int et3=thet3+F[theves+K][thej]-1; 
					if (et3>T-1){et3=T-1;}
					for (t1=thet3;t1<=et3;++t1){
						int theind=HTindex[n][t1]; 
						headway[theind]=1;
					}
				}
				if (theves+K==thej){ 
					int theind=HTindex[n][thet3]; 
					headway[theind]=1;
				}
			}
			int thes1=colshifts[0][thecol];
			int thes2=colshifts[1][thecol];
			for (int n=0;n!=NCPN;++n){
				int thei=ODS[0][n];
				int thej=ODS[1][n];
				if (theves==thei || theves==thej){
					int et01=thet1+D[theves]-1; 
					if (et01>T-1){et01=T-1;}
					for (t1=thet1;t1<=et01;++t1){
						int theind=GTindex[n][t1];
						noncro[theind]=1;
					}			 
				}
				if (theves+K==thei || theves+K==thej){ 
					int et03=thet3+D[theves+K]-1;
					if (et03>T-1){et03=T-1;}
					for (t1=thet3;t1<=et03;++t1){
						int theind=GTindex[n][t1];
						noncro[theind]=1;
					}			 
				}
			}
			int theber=colberth[thecol];
			int thet2=coltimes[1][thecol];
			int et2=thet3-1;
			for (t1=thet2;t1<=et2;++t1){
				int theind=BTindex[theber][t1];
				berocu[theind]=1;
			}
			for (int nn=0;nn!=BDBN[theves][thet1];++nn){
				int thebn=BDindset[theves][thet1][nn];
				double thecof=BDset[theves][thet1][nn];
				bencro[thebn]-=BDCaddable[thebn]*thecof;

			}
			for (int nn=0;nn!=BDBN[theves+K][thet3];++nn){
				int thebn=BDindset[theves+K][thet3][nn];
				double thecof=BDset[theves+K][thet3][nn];
				bencro[thebn]-=BDCaddable[thebn]*thecof;
			}
			int sret1=thet1+D[theves]+MQ[theves][thes1][thet1]-1;
			if (sret1>ST[thes1][1]){
				sret1=ST[thes1][1];
			}
			for (t=thet1;t<=sret1;++t){
				int theind=SRTindex[thes1][t];
				psrcro[theind]-=1;
			}
			int sret3=thet3+D[theves+K]+MQ[theves+K][thes2][thet3]-1;
			if (sret3>ST[thes2][1]){
				sret3=ST[thes2][1];
			}
			for (t=thet3;t<=sret3;++t){
				int theind=SRTindex[thes2][t];
				psrcro[theind]-=1;
			}
			double thecost=colcost[thecol];
			x.add(IloNumVar(Totalcost(colcost[thecol])+Vessel(vescover)+Berocu(berocu)+Hdway(headway)+Noncro(noncro)+Bendcon(bencro)+PSRcon(psrcro)+ENcon(encro))); 
		}
		{
			lpsolver.solve();
			optvalue=LL;
			if(lpsolver.getStatus() ==IloAlgorithm::Optimal){
				optvalue=lpsolver.getObjValue();
				vector<double>().swap(bdsdual);
				bdsdual.resize(BDN);
				vector<double>().swap(srtdual);
				srtdual.resize(SRTN);
				for (i = 0; i < K; i++) {
					vesdual[i] = lpsolver.getDual(Vessel[i]);
				}
				for (i=0;i<BTN; i++){
					berocudual[i]=lpsolver.getDual(Berocu[i]);
				}
				for (i = 0; i < HTN; i++) {
					hdwaydual[i] = lpsolver.getDual(Hdway[i]);
				}
				for (i=0;i<GTN; i++){
					noncrodual[i]=lpsolver.getDual(Noncro[i]);
				}
				for (i=0;i<BDN; i++){
					bdsdual[i]=BDCaddable[i]*lpsolver.getDual(Bendcon[i]);
				}
				for (i=0;i<SRTN; i++){
					srtdual[i]=lpsolver.getDual(PSRcon[i]); 
				}
			}
			MVAL=lpsolver.getObjValue();
		}
	}
	catch(IloException& ex){
		cout<<"size of the model ["<< x.getSize()<<"]"<<endl;
		cerr << ex << endl;
	}
	catch(...){
		cerr << "Error..." << endl;
	}
	N=NN;
	vescover.end();
	headway.end();
	noncro.end();
	berocu.end();
	bencro.end();
	psrcro.end();
	encro.end();
	return MVAL;
}

void bdcutload(int lel,int ind){ 
	for (int nn=0;nn!=BDN;++nn){
		BDCaddable[nn]=0;
	}
	int thelel=lel;
	int theind=ind;
	while (theind!=-1){
		int thecn=bccn[thelel][theind];
		for (int nn=0;nn!=thecn;++nn){
			int thecut=bccset[thelel][theind][nn];
			BDCaddable[thecut]=1;
		}
		int tempind=bcnodeindx[thelel][theind]; 
		theind=tempind;
		thelel-=1;
	}
}

void netload(int lel,int ind,int branch){
	for (int k=0;k!=K;++k){
		for (int b=0;b!=B;++b){
			VKB[k][b]=1;
		}
	}
	for (int i=0;i!=I;++i){
		for (int s=0;s!=S;++s){
			VIS[i][s]=1;
		}
	}
	for (int i=0;i!=I;++i){
		for (int t=E[i][0];t<=E[i][1];++t){
			VIT[i][t]=OVIT[i][t];
		}
	}    
	for (int i=0;i!=I+2;++i){
		for (int j=0;j!=I+2;++j){
			PIID[i][j]=1;
		}
	}
	int thelel=lel;
	int theind=ind;
	int thebranch=branch;
	while (theind!=-1){
		int thetype=brtype[thelel][theind]; 
		int then1=brnd1[thelel][theind]; 
		int then2=brnd2[thelel][theind]; 
		if (thebranch==0){
			if (thetype==1){
				VKB[then1][then2]=0;
			}
			if (thetype==2){
				VIT[then1][then2]=0;
			}
			if (thetype==3){
				VIS[then1][then2]=0;
			}
			if (thetype==4){
				PIID[then1][then2]=0;
			}
		}
		if (thebranch==1){
			if (thetype==1){ 
				for (int i=0;i<then2;++i){
					VKB[then1][i]=0;
				}
				for (int i=then2+1;i<B;++i){
					VKB[then1][i]=0;
				}
			}
			if (thetype==2){ 
				for (int i=E[then1][0];i<then2;++i){
					VIT[then1][i]=0;
				}
				for (int i=then2+1;i<=E[then1][1];++i){
					VIT[then1][i]=0;
				}
			}
			if (thetype==3){ 
				for (int i=0;i<then2;++i){
					VIS[then1][i]=0;
				}
				for (int i=then2+1;i<S;++i){
					VIS[then1][i]=0;
				}
			}
			if (thetype==4){
				if (then1!=I && then1!=I+1){
					for (int i=0;i<then2;++i){
						PIID[then1][i]=0;
					}
					for (int i=then2+1;i<I+2;++i){
						PIID[then1][i]=0;
					}}
				if (then2!=I && then2!=I+1){
					for (int i=0;i<then1;++i){
						PIID[i][then2]=0;
					}
					for (int i=then1+1;i<I+2;++i){
						PIID[i][then2]=0;
					}
				}
			}
		}
		int thefn=fxn[thelel][theind];
		for (int nn=0;nn!=thefn;++nn){
			int theves=fxves[thelel][theind][nn];
			int theber=fxberth[thelel][theind][nn];
			VKB[theves][theber]=0;
		}
		int tempind=nodeindx[thelel][theind][0];
		int tempbranch=nodeindx[thelel][theind][1];
		theind=tempind;
		thebranch=tempbranch;
		thelel-=1;
	}
}

void pathgen(int thev, int berth, int thread){ 
	double acpbd=-0.0001;
	int CA[2]; 
	int CB[2];  
	double basecost=0; 
	basecost+=C3[thev][berth]; 
	basecost-=vesdual[thev]; 
	CA[0]=E[thev][0];
	CA[1]=E[thev][1];
	if (CA[0]<BRT[berth]-D[thev]){ 
		CA[0]=BRT[berth]-D[thev];
	}
	CB[0]=E[thev+K][0];
	CB[1]=E[thev+K][1];
	if (CB[0]<CA[0]+D[thev]+H[thev][berth]){
		CB[0]=CA[0]+D[thev]+H[thev][berth];
	}
	if (CA[1]>CB[1]-D[thev+K]-H[thev][berth]){
		CA[1]=CB[1]-D[thev+K]-H[thev][berth];
	} 
	int flt1=-1; 
	int flt2=-1;  
	int fls1=-1;
	int flt3=-1; 
	int fls3=-1;
	double flcost=LL;
	for (int t=CA[0];t<=CA[1];++t){
		if (VIT[thev][t]==0){
			continue;}
		int tt1=t;
		int tt2=t+D[thev];
		double trc=basecost; 
		trc+=C2[thev][tt1];
		for (int gg=0;gg!=HWPN;++gg){
			int thei=Hset[0][gg];
			int thej=Hset[1][gg];
			if (thev==thei){ 
				int et1=tt1+F[thev][thej]-1;
				if (et1>T-1){et1=T-1;}
				for (int t1=tt1;t1<=et1;++t1){
					int theind=HTindex[gg][t1]; 
					trc-=hdwaydual[theind];
				}
			}
			if (thev==thej){ 
				int theind=HTindex[gg][tt1];
				trc-=hdwaydual[theind];
			}
		}
		for (int gg=0;gg!=NCPN;++gg){
			int thei=ODS[0][gg];
			int thej=ODS[1][gg];
			if (thev==thei || thev==thej){
				int etgg1=tt1+D[thev]-1;
				if (etgg1>T-1){
					etgg1=T-1;
				}
				for (int hh=tt1;hh<=etgg1;++hh){
					int theind=GTindex[gg][hh];
					trc-=noncrodual[theind];
				}		 
			}
		}
		for (int nn=0;nn!=BDBN[thev][tt1];++nn){
			int thebd=BDindset[thev][tt1][nn];
			double thecof=BDset[thev][tt1][nn];
			trc+=bdsdual[thebd]*thecof;}
		double themsrc=LL; 
		int thes1=-1;
		int ther1=-1;
		for (int nn=0;nn!=TSdn[tt1];++nn){ 
			int s1=TSdex[tt1][nn];
			if (VIS[thev][s1]==0){
				continue;
			}
			double tempcost=0;
			int sret1=tt1+D[thev]+MQ[thev][s1][tt1]-1;
			if (sret1>ST[s1][1]){
				sret1=ST[s1][1];
			}
			for (int t=tt1;t<=sret1;++t){
				int tind=SRTindex[s1][t];
				tempcost+=srtdual[tind];}
			if (themsrc>tempcost){
				themsrc=tempcost;
				thes1=s1;}
		}
		trc+=themsrc;
		double ftrc=trc;
		int eet3=tt2+H[thev][berth]; 
		for (int t3=eet3;t3<=CB[1];++t3){ 
			trc=ftrc;
			if (VIT[thev+K][t3]==0){
				continue;}
			int tt3=t3;
			trc+=C2[thev+K][tt3]; 
			for (int hh=tt2;hh<tt3;++hh){
				int theind=BTindex[berth][hh];
				trc-=berocudual[theind];
			}
			for (int gg=0;gg!=HWPN;++gg){
				int thei=Hset[0][gg];
				int thej=Hset[1][gg];
				if (thev+K==thei){ 
					int et3=tt3+F[thev+K][thej]-1;
					if (et3>T-1){et3=T-1;}
					for (int t1=tt3;t1<=et3;++t1){
						int theind=HTindex[gg][t1]; 
						trc-=hdwaydual[theind];
					}
				}
				if (thev+K==thej){ 
					int theind=HTindex[gg][tt3]; 
					trc-=hdwaydual[theind];
				}
			}
			for (int gg=0;gg!=NCPN;++gg){
				int thei=ODS[0][gg];
				int thej=ODS[1][gg];
				if (thev+K==thei || thev+K==thej){
					int etgg3=tt3+D[thev+K]-1;
					if (etgg3>T-1){
						etgg3=T-1;
					}
					for (int hh=tt3;hh<=etgg3;++hh){
						int theind=GTindex[gg][hh];
						trc-=noncrodual[theind];
					}		 
				}
			}
			for (int nn=0;nn!=BDBN[thev+K][tt3];++nn){
				int thebd=BDindset[thev+K][tt3][nn];
				double thecof=BDset[thev+K][tt3][nn];
				trc+=bdsdual[thebd]*thecof;}
			themsrc=LL;  
			int thes3=-1;
			for (int nn=0;nn!=TSdn[tt3];++nn){
				int s3=TSdex[tt3][nn];
				if (VIS[thev+K][s3]==0){
					continue;
				}
				double tempcost=0; 
				int sret3=tt3+D[thev+K]+MQ[thev+K][s3][tt3]-1;
				if (sret3>ST[s3][1]){
					sret3=ST[s3][1];
				}
				for (int t=tt3;t<=sret3;++t){
					int tind=SRTindex[s3][t];
					tempcost+=srtdual[tind];}
				if (themsrc>tempcost){
					themsrc=tempcost;
					thes3=s3;
				}
			}
			trc+=themsrc;
			if (trc<flcost){
				flcost=trc; 
				flt1=tt1;
				flt2=tt2;
				fls1=thes1;
				flt3=tt3;
				fls3=thes3;
			}
		}
	}
	BVBD[berth][thev]=flcost;
	if (flcost<acpbd){ 
		CRTLB+=flcost;
		NCOLN[thread]+=1;
		prcolves[thread].resize(NCOLN[thread],thev);
		prcolberth[thread].resize(NCOLN[thread],berth);
		prcoltimes[thread][0].resize(NCOLN[thread],flt1);
		prcoltimes[thread][1].resize(NCOLN[thread],flt2);
		prcoltimes[thread][2].resize(NCOLN[thread],flt3);
		prcolshifts[thread][0].resize(NCOLN[thread],fls1);
		prcolshifts[thread][1].resize(NCOLN[thread],fls3);
		double comcost=0;
		comcost+=C2[thev][flt1]+C2[thev+K][flt3]+C3[thev][berth];
		prcolcost[thread].resize(NCOLN[thread],comcost);
	}
}

int colgen(int lel, int ind, int branch){ 
	int newcol=0;	
	for (int nn=0;nn!=TTRD;++nn){
		NCOLN[nn]=0;
		vector<int>().swap(prcolves[nn]);
		vector<int>().swap(prcolberth[nn]);
		vector<double>().swap(prcolcost[nn]);
		for (int mm=0;mm!=3;++mm){
			vector<int>().swap(prcoltimes[nn][mm]);
		}
		for (int mm=0;mm!=2;++mm){
			vector<int>().swap(prcolshifts[nn][mm]);
		}
	} 
#pragma omp parallel sections num_threads(6)
	{
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[0];++mm){
				int k=PVset[0][mm];
				int b=PBset[0][mm];
				if (VKB[k][b]==1){
					pathgen(k,b,0);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[1];++mm){
				int k=PVset[1][mm];
				int b=PBset[1][mm];
				if (VKB[k][b]==1){
					pathgen(k,b,1);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[2];++mm){
				int k=PVset[2][mm];
				int b=PBset[2][mm];
				if (VKB[k][b]==1){
					pathgen(k,b,2);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[3];++mm){
				int k=PVset[3][mm];
				int b=PBset[3][mm];
				if (VKB[k][b]==1){
					pathgen(k,b,3);}
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[4];++mm){
				int k=PVset[4][mm];
				int b=PBset[4][mm];
				if (VKB[k][b]==1){
					pathgen(k,b,4);}
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PRTN[5];++mm){
				int k=PVset[5][mm];
				int b=PBset[5][mm];
				if (VKB[k][b]==1){
					pathgen(k,b,5);}
			}
		}									
	}
	for (int thread=0;thread!=TTRD;++thread){
		newcol+=NCOLN[thread];
		for (int mm=0;mm!=NCOLN[thread];++mm){
			NN+=1; 
			TON+=1; 
			int thev=prcolves[thread][mm];
			colves.resize(TON,thev);
			int berth=prcolberth[thread][mm];
			colberth.resize(TON,berth);
			int tt1=prcoltimes[thread][0][mm];
			coltimes[0].resize(TON,tt1);
			int tt2=prcoltimes[thread][1][mm];
			coltimes[1].resize(TON,tt2);
			int tt3=prcoltimes[thread][2][mm];
			coltimes[2].resize(TON,tt3);
			int ts1=prcolshifts[thread][0][mm];
			colshifts[0].resize(TON,ts1);
			int ts3=prcolshifts[thread][1][mm];
			colshifts[1].resize(TON,ts3);
			double thecost=prcolcost[thread][mm];
			colcost.resize(TON,thecost);
		}
	} 
	return newcol;
}

void PCGsetup(int create){ 
	if (create==1){
		ITN=0;
		for (int k=0;k!=K;++k){
			for (int n=0;n!=nt1used[k]; ++n){
				int thet=usedt1[k][n];
				Iset[ITN]=k;
				Tset[ITN]=thet;
				ITN+=1;
			}
		}
		for (int k=0;k!=K;++k){
			for (int n=0;n!=nt3used[k]; ++n){
				int thet=usedt3[k][n];
				Iset[ITN]=k+K;
				Tset[ITN]=thet;
				ITN+=1;
			}
		}
	}
	InsertionSort(Tset,Iset,ITN);  
	if (create==1){
		vector<double>().swap(ITres);
		ITres.resize(ITN);
		for (int nn=0;nn!=ITN;++nn){
			int thei=Iset[nn];
			int thet=Tset[nn];
			if (thei<K){
				ITres[nn]=T1result[thei][thet];}
			else {
				ITres[nn]=T3result[thei-K][thet];
			}
		}
	}
	vector<double>().swap(ptaskdual);
	ptaskdual.resize(ITN);
}

void Pshrink(){
	for (int s=0;s!=S;++s){
		SITN[s]=0; 
	}
	for (int s=0;s!=S;++s){
		vector<int>().swap(SIS[s]);
	}
	for (int n=0;n!=ITN;++n){
		int thei=Iset[n];
		int thet=Tset[n];
		for (int m=0;m!=TSdn[thet];++m){
			int thes=TSdex[thet][m];
			SITN[thes]+=1;
			SIS[thes].resize(SITN[thes],n);
		}
	}
}

void PinputData (int create) { 
	PCGsetup(create);
	Pshrink();
	pupperbound=PLL;
	ptotallb=-PLL;
	vector<int>().swap(pcolshift);	
	vector<double>().swap(pcolcost);	
	vector<int>().swap(pcollen);	
	for (int nn=0;nn!=PTON;++nn){
		vector<int>().swap(pcoltasks[nn]);}
	PTON=0; 
}

void PInicolload(IloModel model,IloNumVarArray x){ 
	IloEnv env = model.getEnv(); 
	IloInt j,k;   
	IloNumArray taskcover(env, ITN);    
	for (j = 0; j < ITN; j++) {  
		for (k=0;k!=ITN;++k){taskcover[k]=0;}
		taskcover[j]=1;
		double thecost=10000;
		x.add(IloNumVar(PTotalcost(thecost) + PTask(taskcover)+PTask02(taskcover)));  
	}
	PN=0;
	PNN=PN;
}

double pmasterproblem (IloModel model,IloCplex lpsolver,IloNumVarArray x,int numsc) {
	IloEnv env = model.getEnv(); 
	double MVAL;
	double optvalue;
	IloInt j,k;   
	IloNumArray taskcover(env, ITN);     
	try{
		for (j = PN; j < numsc; j++) { 
			for (k=0;k!=ITN;++k){taskcover[k]=0;}
			int thecol=j; 
			int thelen=pcollen[thecol];
			for (int nn=0;nn!=thelen;++nn){
				int thect=pcoltasks[thecol][nn]; 
				if (thect!=-1){ 
					taskcover[thect]=1;
				} 
			}
			double thecost=pcolcost[thecol];
			x.add(IloNumVar(PTotalcost(pcolcost[thecol])+PTask(taskcover)+PTask02(taskcover))); 
		}
		{
			lpsolver.solve();
			optvalue=PLL;
			if(lpsolver.getStatus() ==IloAlgorithm::Optimal){
				optvalue=lpsolver.getObjValue();
				for (int gg=0;gg<ITN; ++gg){
					ptaskdual[gg]=lpsolver.getDual(PTask[gg])+lpsolver.getDual(PTask02[gg]);
				}
			}
			MVAL=lpsolver.getObjValue();
		}
	}
	catch(IloException& ex){
		cerr << ex << endl;
	}
	catch(...){
		cerr << "Error..." << endl;
	}
	PN=PNN; 
	return MVAL;
}

void ppathgen(int shift, int thread){ 
	double acpbd=-0.0001;
	double basecost=0; 
	basecost+=C4[shift];
	int tfln=0; 
	vector<int> ftset; 
	vector<double> flcost (ITN);
	vector<int> fllen(ITN); 
	vector<vector<int>> flind(ITN);
	int LRT=BRK[shift][1];
	for (int nn=0;nn!=SITN[shift];++nn){
		int theind=SIS[shift][nn]; 
		int thei=Iset[theind];
		int thet=Tset[theind];
		if (VIS[thei][shift]==0){
			continue;
		}
		if (thet+D[thei]<=LRT){ 
			tfln+=1;
			ftset.resize(tfln,theind);
			fllen[theind]=1;
			flind[theind].resize(1,theind);
			flcost[theind]=-ptaskdual[theind];
			if (PIID[I+1][thei]==0){ 
				flcost[theind]=PLL;
			}
		}
		else {
			break;
		}
	}
	for (int ln=0;ln<tfln-1;++ln){
		int lind=ftset[ln]; 
		int ltask=Iset[lind];
		int ltime=Tset[lind];;
		int llen=fllen[lind];
		double lcost=flcost[lind];
		for (int fn=ln+1;fn<tfln;++fn){ 
			int find=ftset[fn]; 
			int ftask=Iset[find];
			int ftime=Tset[find];
			if (PIID[ltask][ftask]==0){  
				continue;
			}
			if (ltask!=ftask&&ltime+D[ltask]+Q[ltask][ftask]<=ftime){  
				if (lcost-ptaskdual[find]<flcost[find]){ 
					flcost[find]=lcost-ptaskdual[find];
					int flen=llen+1;
					fllen[find]=flen; 
					vector<int>().swap(flind[find]);
					for (int nn=0;nn!=llen;++nn){
						int temp=flind[lind][nn];
						flind[find].resize(nn+1,temp);
					}
					flind[find].resize(flen,find);
				}
			}
		}
	}
	int tbln=0; 
	vector<int> btset; 
	vector<double> blcost (ITN); 
	vector<int> bllen(ITN); 
	vector<vector<int>> blind(ITN); 
	int ERT=BRK[shift][0];
	for (int nn=0;nn!=SITN[shift];++nn){
		int theind=SIS[shift][nn];
		int thei=Iset[theind];
		int thet=Tset[theind];
		if (VIS[thei][shift]==0){
			continue;
		}
		int thetime=thet; 
		if (thetime<ERT+D[I]){  
			continue;
		}
		tbln+=1;
		btset.resize(tbln,theind);
		bllen[theind]=1;
		blind[theind].resize(1,theind);
		blcost[theind]=-ptaskdual[theind];
		if (PIID[thei][I+1]==0){ 
			blcost[theind]=PLL; 
		}
	}
	for (int fn=tbln-1;fn>=1;--fn){  
		int find=btset[fn];
		int ftask=Iset[find];
		int ftime=Tset[find];
		int flen=bllen[find];
		double fcost=blcost[find];
		for (int ln=fn-1;ln>=0;--ln){
			int lind=btset[ln];
			int ltask=Iset[lind];
			int ltime=Tset[lind];
			if (PIID[ltask][ftask]==0){
				continue;
			}
			if (ltask!=ftask&&ltime+D[ltask]+Q[ltask][ftask]<=ftime){ 
				if (fcost-ptaskdual[lind]<blcost[lind]){ 
					blcost[lind]=fcost-ptaskdual[lind];
					int llen=flen+1;
					bllen[lind]=llen;
					vector<int>().swap(blind[lind]);
					blind[lind].resize(1,lind);
					for (int nn=1;nn<llen;++nn){
						int temp=blind[find][nn-1];
						blind[lind].resize(nn+1,temp);
					}
				}
			}
		}
	}
	int seft=-1; 
	int sebt=-1;  
	double theminival=acpbd;
	for (int ln=0;ln!=tfln;++ln){
		int thelind=ftset[ln];
		int thelt=Iset[thelind];
		if (PIID[thelt][I]==0){ 
			continue;
		}
		double tempcost=basecost+flcost[thelind];
		if (theminival>tempcost){
			seft=thelind;
			theminival=tempcost;
			sebt=-1;
		}
	}
	for (int fn=0;fn!=tbln;++fn){
		int thefind=btset[fn];
		int thebt=Iset[thefind];
		if (PIID[I][thebt]==0){
			continue;
		}
		double tempcost=basecost+blcost[thefind];
		if (theminival>tempcost){
			seft=-1;
			sebt=thefind;  
			theminival=tempcost;
		}
	}
	for (int ln=0;ln!=tfln;++ln){
		int thelind=ftset[ln];
		int thelt=Iset[thelind];
		int theltime=Tset[thelind];
		if (PIID[thelt][I]==0){ 
			continue;
		}
		int lrstime=theltime+D[thelt];
		int ltime=theltime;
		if (lrstime<BRK[shift][0]){
			lrstime=BRK[shift][0];
		}
		for (int fn=0;fn!=tbln;++fn){
			int thebind=btset[fn];
			int thebt=Iset[thebind];
			int theftime=Tset[thebind];
			if (PIID[I][thebt]==0){
				continue;
			}
			int brstime=theftime-D[I]; 
			if (brstime>BRK[shift][1]){
				brstime=BRK[shift][1];
			}
			if (lrstime>brstime){ 
				continue;
			}
			int ftime=theftime; 
			if (thelt!=thebt&&ltime+D[thelt]+Q[thelt][thebt]<=ftime){
				double tempcost=basecost+flcost[thelind]+blcost[thebind];
				if (theminival>tempcost){
					theminival=tempcost;
					seft=thelind;
					sebt=thebind;
				}
			}
		}
	}
	if (theminival<acpbd){
		NCOLN[thread]+=1;
		prpcolshift[thread].resize(NCOLN[thread],shift);
		prpcoltasks[thread].resize(NCOLN[thread]);
		int templen=0;
		if (seft!=-1){
			for (int nn=0;nn!=fllen[seft];++nn){
				templen+=1;
				int tempind=flind[seft][nn];
				prpcoltasks[thread][NCOLN[thread]-1].resize(templen,tempind);
			}
		}
		templen+=1;
		prpcoltasks[thread][NCOLN[thread]-1].resize(templen,-1);
		if (sebt!=-1){
			for (int nn=0;nn!=bllen[sebt];++nn){
				templen+=1;
				int tempind=blind[sebt][nn];
				prpcoltasks[thread][NCOLN[thread]-1].resize(templen,tempind);
			}
		}
		prpcollen[thread].resize(NCOLN[thread],templen);
		prpcolcost[thread].resize(NCOLN[thread],basecost);
	}
}

int pcolgen(){
	int newcol=0;	
	for (int nn=0;nn!=TTRD;++nn){
		vector<int>().swap(prpcolshift[nn]);
		vector<double>().swap(prpcolcost[nn]);
		for (int mm=0;mm!=NCOLN[nn];++mm){
			vector<int>().swap(prpcoltasks[nn][mm]);
		}
		vector<int>().swap(prpcollen[nn]);
		NCOLN[nn]=0;
	}
#pragma omp parallel sections num_threads(6)
	{
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[0];++mm){
				int s=PPSset[0][mm];
				if (SITN[s]>0){
					ppathgen(s,0);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[1];++mm){
				int s=PPSset[1][mm];
				if (SITN[s]>0){
					ppathgen(s,1);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[2];++mm){
				int s=PPSset[2][mm];
				if (SITN[s]>0){
					ppathgen(s,2);}
			}
		}
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[3];++mm){
				int s=PPSset[3][mm];
				if (SITN[s]>0){
					ppathgen(s,3);}
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[4];++mm){
				int s=PPSset[4][mm];
				if (SITN[s]>0){
					ppathgen(s,4);}	
			}
		}			
#pragma omp section
		{
			for (int mm=0;mm!=PPRTN[5];++mm){
				int s=PPSset[5][mm];
				if (SITN[s]>0){
					ppathgen(s,5);}
			}
		}									
	}
	for (int thread=0;thread!=TTRD;++thread){
		newcol+=NCOLN[thread];
		for (int mm=0;mm!=NCOLN[thread];++mm){
			PNN+=1; 
			PTON+=1;
			int shift=prpcolshift[thread][mm];
			pcolshift.resize(PTON,shift);
			double basecost=prpcolcost[thread][mm];
			pcolcost.resize(PTON,basecost);
			int templen=prpcollen[thread][mm];
			pcollen.resize(PTON,templen);
			pcoltasks.resize(PTON);
			for (int tt=0;tt!=templen;++tt){
				int theind= prpcoltasks[thread][mm][tt];
				pcoltasks[PTON-1].resize(tt+1,theind);
			}
		}
	} 
	return newcol;
}

double pmastersolver(int create){ 
	PinputData (create);
	IloEnv env;     
	IloModel msmodel(env);
	IloCplex lpsolver(msmodel);
	lpsolver.setOut(env.getNullStream());
	lpsolver.setParam(IloCplex::Threads, 1); 
	IloNumVarArray x(env); 
	IloInt i;   
	PTotalcost = IloAdd(msmodel, IloMinimize(env));
	IloNumArray taskreach(env, ITN); 
	for (i=0;i!=ITN;++i){taskreach[i]=ITres[i];} 
	PTask = IloAdd(msmodel, IloRangeArray(env, taskreach, IloInfinity));  
	PTask02 = IloAdd(msmodel, IloRangeArray(env, -IloInfinity, taskreach));
	PInicolload(msmodel,x);
	double lwbd;
	lwbd=pmasterproblem(msmodel,lpsolver,x,PNN); 
	int ncs=pcolgen();
	while (ncs>0){
		lwbd=pmasterproblem(msmodel,lpsolver,x,PNN);
		ncs=pcolgen();
	}
	Pintsol=1;
	pnumused=0;
	vector<int>().swap(pusedcol);
	vector<double>().swap(pusedcolval);
	for (IloInt j = 0; j <PNN; j++) {  
		double trv=lpsolver.getValue(x[j+ITN]);		
		if (trv>0.0001){
			if (trv<0.99){Pintsol=0;}  
			int h=int(j);
			pnumused+=1;
			pusedcol.resize(pnumused,h);	
			pusedcolval.resize(pnumused,trv);
		}
	}
	env.end();
	return lwbd;
}

double Primal(int Mintsol, int crtpintsol,double mobj){
	double thecost=mobj;
	double uppsc=PLL;
	double theintsol=LL;
	int DVN=0;
	if (Mintsol==0){
		for (int j=1; j<numused; j++) {  
			double key = usedcolval[j];  
			int i = j-1;  
			while (i>=0 && usedcolval[i]<key)  
			{  
				usedcolval[i+1] = usedcolval[i];
				int temp=usedcol[i+1];
				usedcol[i+1]=usedcol[i];
				usedcol[i]=temp;
				i--;  
			}  
			usedcolval[i+1] = key;  
		}  
		int feasi=1;
		ITN=0;
		vector<double>().swap(ITres);
		int VESDO[K]; 
		for (int k=0;k!=K;++k){
			VESDO[k]=0;
		}
		int BOSN[B];
		vector<vector<vector<int>>>BOSset(B);
		for (int b=0;b!=B;++b){
			BOSN[b]=0;
			BOSset[b].resize(2);
		}
		int INTN=0; 
		vector<vector<int>> INTset(2);
		int OUTTN=0; 
		vector<vector<int>> OUTTset(2);
		int LINTN=0;
		vector<vector<int>>LINTset(2); 
		int LOUTTN=0; 
		vector<vector<int>>LOUTTset(2); 
		thecost=0;
		for (int n=0;n!=numused;++n){
			int thecol=usedcol[n]; 
			int theves=colves[thecol];
			if (VESDO[theves]==1){  
				continue;
			}
			int theber=colberth[thecol]; 
			int theint=coltimes[0][thecol]; 
			int thebst=coltimes[1][thecol]; 
			int theoutt=coltimes[2][thecol]; 
			feasi=1;
			for (int itn=0;itn<INTN;++itn){
				feasi=0;
				int cves=INTset[0][itn];
				int cst=INTset[1][itn];
				int est=cst+F[cves][theves];
				int theinend=theint+F[theves][cves];
				if (est<=theint || cst>=theinend){
					feasi=1;
				}
				if (feasi==0){
					break;
				}
			}
			if (feasi==1){
				for (int otn=0;otn<OUTTN;++otn){
					feasi=0;
					int cves=OUTTset[0][otn];
					int cst=OUTTset[1][otn];
					int est=cst+F[cves+K][theves+K];
					int theoutend=theoutt+F[theves+K][cves+K];
					if (est<=theoutt || cst>=theoutend){
						feasi=1;
					}
					if (feasi==0){
						break;
					}
				}
			}
			if (feasi==1){
				for (int bn=0;bn<BOSN[theber];++bn){
					feasi=0;
					int cst=BOSset[theber][0][bn];
					int est=BOSset[theber][1][bn];
					if (est<=thebst || cst>=theoutt){
						feasi=1;
					}
					if (feasi==0){
						break;
					}
				}
			}
			if (feasi==1){
				if (VLL[theves]>=2){ 
					for (int cn=0; cn<LINTN;++cn){
						feasi=0;
						int cst=LINTset[0][cn];
						int est=LINTset[1][cn];
						int theinend=theint+D[theves];
						if (est<=theint || cst>=theinend){
							feasi=1;
						}
						if (feasi==0){
							break;
						}
					}
				}
			}
			if (feasi==1){
				if (VLL[theves]>=2){
					for (int cn=0; cn<LOUTTN;++cn){
						feasi=0;
						int cst=LOUTTset[0][cn];
						int est=LOUTTset[1][cn];
						int theinend=theoutt+D[theves+K];
						if (est<=theoutt || cst>=theinend){
							feasi=1;
						}
						if (feasi==0){
							break;
						}
					}
				}
			}
			if (feasi==1){ 
				VESDO[theves]=1;
				DVN+=1;
				BOSN[theber]+=1;
				BOSset[theber][0].resize(BOSN[theber],thebst);
				BOSset[theber][1].resize(BOSN[theber],theoutt);
				INTN+=1;
				INTset[0].resize(INTN,theves);
				INTset[1].resize(INTN,theint);
				Iset[ITN]=theves;
				Tset[ITN]=theint;
				ITN+=1;
				ITres.resize(ITN,1);
				OUTTN+=1;
				OUTTset[0].resize(OUTTN,theves);
				OUTTset[1].resize(OUTTN,theoutt);
				Iset[ITN]=theves+K;
				Tset[ITN]=theoutt;
				ITN+=1;
				ITres.resize(ITN,1);
				if (VLL[theves]>=2){
					LINTN+=1;
					LINTset[0].resize(LINTN,theoutt);
					LINTset[1].resize(LINTN,theoutt+D[theves+K]);
					LOUTTN+=1;
					LOUTTset[0].resize(LOUTTN,theint);
					LOUTTset[1].resize(LOUTTN,theint+D[theves]);
				}
				thecost+=colcost[thecol];
			}
			if (DVN>=K){
				break;
			}
		}
		if (DVN<K){  
			for (int k=0;k!=K;++k){
				if (VESDO[k]>0.99){continue;}
				int theves=k;
				int theberth=-1;
				int entime=-1;
				int lvtime=-1;
				int feasi=1; 
				for (int theint=E[theves][0];theint<=E[theves][1];++theint){
					if (OVIT[theves][theint]==0){continue;}
					for (int theoutt=E[theves+K][0];theoutt<=E[theves+K][1];++theoutt){
						if (OVIT[K+theves][theoutt]==0){continue;}
						for (int itn=0;itn<INTN;++itn){
							feasi=0;
							int cves=INTset[0][itn];
							int cst=INTset[1][itn];
							int est=cst+F[cves][theves];
							int theinend=theint+F[theves][cves];
							if (est<=theint || cst>=theinend){
								feasi=1;
							}
							if (feasi==0){
								break;
							}
						}
						if (feasi==1){
							for (int otn=0;otn<OUTTN;++otn){
								feasi=0;
								int cves=OUTTset[0][otn];
								int cst=OUTTset[1][otn];
								int est=cst+F[cves+K][theves+K];
								int theoutend=theoutt+F[theves+K][cves+K];
								if (est<=theoutt || cst>=theoutend){
									feasi=1;
								}
								if (feasi==0){
									break;
								}
							}
						}
						if (feasi==1){
							if (VLL[theves]>=2){ 
								for (int cn=0; cn<LINTN;++cn){
									feasi=0;
									int cst=LINTset[0][cn];
									int est=LINTset[1][cn];
									int theinend=theint+D[theves];
									if (est<=theint || cst>=theinend){
										feasi=1;
									}
									if (feasi==0){
										break;
									}
								}
							}
						}
						if (feasi==1){
							if (VLL[theves]>=2){
								for (int cn=0; cn<LOUTTN;++cn){
									feasi=0;
									int cst=LOUTTset[0][cn];
									int est=LOUTTset[1][cn];
									int theinend=theoutt+D[theves+K];
									if (est<=theoutt || cst>=theinend){
										feasi=1;
									}
									if (feasi==0){
										break;
									}
								}
							}
						}
						if (feasi==1){
							for (int thb=0;thb!=B;++thb){
								int theber=BSEQ[theves][thb];
								feasi=1;
								if (theint+D[theves]<BRT[theber]){
									feasi=0;
									continue;
								}
								if (theint+D[theves]+H[theves][theber]>theoutt){
									feasi=0;
									continue;  
								}
								if (feasi==1){
									int thebst=theint+D[theves];
									for (int bn=0;bn<BOSN[theber];++bn){
										feasi=0;
										int cst=BOSset[theber][0][bn];
										int est=BOSset[theber][1][bn];
										if (est<=thebst || cst>=theoutt){
											feasi=1;
										}
										if (feasi==0){
											break;
										}
									}
								}
								if (feasi==1){
									theberth=theber;
									break;
								}
							}
						}
						if (feasi==1){
							lvtime=theoutt;
						    break;
						}
					}
					if (feasi==1){
						entime=theint;
						break;
					}
				}
				
				if (feasi==1){
					VESDO[theves]=1;
					DVN+=1;
					int thebst=entime+D[theves];
					BOSN[theberth]+=1;
					BOSset[theberth][0].resize(BOSN[theberth],thebst);
					BOSset[theberth][1].resize(BOSN[theberth],lvtime);
					INTN+=1;
					INTset[0].resize(INTN,theves);
					INTset[1].resize(INTN,entime);
					Iset[ITN]=theves;
					Tset[ITN]=entime;
					ITN+=1;
					ITres.resize(ITN,1);
					OUTTN+=1;
					OUTTset[0].resize(OUTTN,theves);
					OUTTset[1].resize(OUTTN,lvtime);
					Iset[ITN]=theves+K;
					Tset[ITN]=lvtime;
					ITN+=1;
					ITres.resize(ITN,1);
					if (VLL[theves]>=2){
						LINTN+=1;
						LINTset[0].resize(LINTN,lvtime);
						LINTset[1].resize(LINTN,lvtime+D[theves+K]);
						LOUTTN+=1;
						LOUTTset[0].resize(LOUTTN,entime);
						LOUTTset[1].resize(LOUTTN,entime+D[theves]);
					}
					thecost+=C2[theves][entime]+C2[K+theves][lvtime]+C3[theves][theberth];
				}	
			}
		}
		if (DVN==K){ 
			double tempcost=pmastersolver(0);
			crtpintsol=Pintsol;
			if (Pintsol==1){
				uppsc=tempcost;
				theintsol=thecost+uppsc;
				if (upperbound>thecost+uppsc){
					upperbound=thecost+uppsc;
					cout<<"a new upper bound is found by construction-I: "<<upperbound<<endl;
				}
			}
		}
	}
	if (Mintsol==1 || DVN==K){
		if (crtpintsol==0){
			uppsc=0;
			for (int j=1; j<pnumused; j++)   
			{  
				double key = pusedcolval[j];  
				int i = j-1;  
				while (i>=0 && pusedcolval[i]<key)  
				{  
					pusedcolval[i+1] = pusedcolval[i];
					int temp=pusedcol[i+1];
					pusedcol[i+1]=pusedcol[i];
					pusedcol[i]=temp;
					i--;  
				}  
				pusedcolval[i+1] = key;  
			}  
			int Visted=0;
			for (int n=0;n!=pnumused;++n){
				int addable=0;
				int thecol=pusedcol[n];
				int thelen=pcollen[thecol];
				int theshift=pcolshift[thecol];
				for (int m=0;m!=thelen;++m){
					int theind=pcoltasks[thecol][m];
					if (theind!=-1){
						if (ITres[theind]>0.99){ 
							Visted+=1;
							addable=1;
							int thetask=Iset[theind];
							ITres[theind]=0;
						}
					}
				}
				if (addable==1){
					uppsc+=C4[theshift];
				}
				if (Visted>=ITN){
					break;
				}
			}
			if (Visted<ITN){
				for (int theind=0;theind!=ITN;++theind){
					if (ITres[theind]>0.99){ 
						int thetask=Iset[theind];
						int thetime=Tset[theind];
						double themcost=PLL;
						for (int mm=0;mm!=TSdn[thetime];++mm){
							int theshift=TSdex[thetime][mm];
							if (C4[theshift]<themcost){
								themcost=C4[theshift];
							}
						}
						uppsc+=themcost;
						Visted+=1;
					}
				}
			}
		}
		theintsol=thecost+uppsc;
		if (upperbound>theintsol){
			upperbound=theintsol;
			cout<<"a new upper bound is found by construction-II: "<<upperbound<<endl;
		}
	}
	return theintsol;
}

double mastersolver(int lel, int ind, int branch, double sepe){
	int ctrbdlv=0; 
	int crtbdnd=0; 
	int crtfn=0;
	vector<int> crtfv;
	vector<int> crtfb;
	if (lel!=-1){ 
		ctrbdlv=bendcutnode[0][lel][ind];   
		crtbdnd=bendcutnode[1][lel][ind]; 
		int thetype=brtype[lel][ind]; 
		if (thetype>=3){ 
			ctrbdlv+=1; 
			if (ctrbdlv+1>bclevels){
				bclevels+=1;
				bcnodeindx.resize(bclevels);
				bcnodenum.resize(bclevels,0);
				bccn.resize(bclevels);
				bccset.resize(bclevels);
			}
			bcnodenum[ctrbdlv]+=1; 
			bcnodeindx[ctrbdlv].resize(bcnodenum[ctrbdlv],crtbdnd); 
			bccn[ctrbdlv].resize(bcnodenum[ctrbdlv],0);
			bccset[ctrbdlv].resize(bcnodenum[ctrbdlv]);
			crtbdnd=bcnodenum[ctrbdlv]-1; 

		}
	}
	int feasi=0; 
	bdcutload(ctrbdlv,crtbdnd); 
	int crtusedbcn=0;
	vector<int>	usedbcset; 
	netload(lel,ind,branch);
	int berused[K];
	vector<vector<int>> usedbt(K); 
	double KBresult[K][B]; 
	double lwbd;
	double lwpsc;
	double uppsc;
	double thegap;
	int mintsol=1;  
	numused=0;
	vector<int>().swap(usedcol);
	while (feasi==0){
		feasi=1;
		IloEnv env;    
		IloModel msmodel(env);
		IloCplex lpsolver(msmodel);
		lpsolver.setOut(env.getNullStream());
		lpsolver.setParam(IloCplex::Threads, 1);  
		IloNumVarArray x(env);     
		IloInt i;   
		Totalcost = IloAdd(msmodel, IloMinimize(env));
		IloNumArray vesreach(env, K);  
		for (i=0;i!=K;++i){vesreach[i]=1;} 
		Vessel = IloAdd(msmodel, IloRangeArray(env, vesreach, IloInfinity));  
		IloNumArray flheadway(env, HTN);  
		for (i=0;i!=HTN;++i){flheadway[i]=1;} 
		Hdway= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, flheadway)); 
		IloNumArray bicross(env, GTN);  
		for (i=0;i!=GTN;++i){bicross[i]=1;}
		Noncro= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, bicross)); 
		IloNumArray berthtime(env, BTN); 
		for (i=0;i!=BTN;++i){berthtime[i]=1;}
		Berocu= IloAdd(msmodel, IloRangeArray(env, -IloInfinity, berthtime));  
		IloNumArray bendocu(env, BDN);  
		for (i=0;i!=BDN;++i){bendocu[i]=0;}
		Bendcon= IloAdd(msmodel, IloRangeArray(env, bendocu, IloInfinity));  
		IloNumArray srtocu(env, SRTN);  
		for (i=0;i!=SRTN;++i){srtocu[i]=0;} 
		PSRcon=IloAdd(msmodel, IloRangeArray(env, srtocu, IloInfinity)); 
		IloNumArray enocu(env, 1);  
		enocu[0]=0;
		ENcon=IloAdd(msmodel, IloRangeArray(env, enocu, IloInfinity)); 
		Inicolload(msmodel,x);
		lwbd=masterproblem(msmodel,lpsolver,x,NN);
		int ncs=colgen(lel,ind,branch);
		while (ncs>0){
			lwbd=masterproblem(msmodel,lpsolver,x,NN);
			CRTLB=lwbd;
			ncs=colgen(lel,ind,branch);
			for (int bb=0;bb!=B;++bb){
				for (int kk=0;kk!=K;++kk){
					if (VKB[kk][bb]==1 && ceil(CRTLB+BVBD[bb][kk]-0.01)>=upperbound){
						VKB[kk][bb]=0;
						crtfn+=1;
						crtfv.resize(crtfn,kk);
						crtfb.resize(crtfn,bb);
					}
				}
			}
		}
		lwbd=ceil(lwbd-0.01);
		if (lwbd<upperbound-0.01){
			for (int k1=0;k1!=K;++k1){
				vector<int>().swap(usedbt[k1]);
				for (int b=0;b!=B;++b){
					KBresult[k1][b]=0;
				}
			}
			for (int k=0;k!=K;++k){
				berused[k]=0;
				nt1used[k]=0;
				vector<int>().swap(usedt1[k]);
				nt3used[k]=0;
				vector<int>().swap(usedt3[k]);
			}
			for (int k1=0;k1!=K;++k1){
				for (int t1=0;t1!=T;++t1){
					T1result[k1][t1]=0;
					T3result[k1][t1]=0;
				}
			}
			mintsol=1;
			for (IloInt j = 0; j <NN; j++) {
				double trv=lpsolver.getValue(x[j+1+S+K]);	
				if (trv>0.001){
					int h=j; 
					numused+=1;
					usedcol.resize(numused,h);	
					usedcolval.resize(numused,trv);
					int theves=colves[h];
					int theber=colberth[h]; 
					int tt1=coltimes[0][h];
					int tt3=coltimes[2][h];
					if (KBresult[theves][theber]==0){
						berused[theves]+=1;
						usedbt[theves].resize(berused[theves],theber);
						if (berused[theves]>1.01){mintsol=0;} 
					}
					KBresult[theves][theber]+=trv;
					if (T1result[theves][tt1]==0){
						nt1used[theves]+=1;
						usedt1[theves].resize(nt1used[theves],tt1);
						if (nt1used[theves]>1.01){mintsol=0;} 
					}
					T1result[theves][tt1]+=trv;
					if (T3result[theves][tt3]==0){
						nt3used[theves]+=1;
						usedt3[theves].resize(nt3used[theves],tt3);
						if (nt3used[theves]>1.01){mintsol=0;} 
					}
					T3result[theves][tt3]+=trv;
				}
			}
			lwpsc=lpsolver.getValue(x[0]); 
			uppsc=pmastersolver(1);
			thegap=100*(uppsc-lwpsc)/double(lwbd);
			if (thegap>sepe){
				if (mintsol==1 && Pintsol==1){
					if (lwbd-lwpsc+uppsc<upperbound){
						upperbound=lwbd-lwpsc+uppsc;
						cout<<"an upperbound found by ph 1: "<<upperbound<<endl;
					}
				}
				feasi=0;
				for (int nn=0;nn!=ITN;++nn){
					int thei=Iset[nn];
					int thet=Tset[nn];
					double thedual=ptaskdual[nn];
					BDBN[thei][thet]+=1;
					BDindset[thei][thet].resize(BDBN[thei][thet],BDN);
					BDset[thei][thet].resize(BDBN[thei][thet],thedual);
				}
				crtusedbcn+=1;
				usedbcset.resize(crtusedbcn,BDN);
				BDN+=1; 
				BDCaddable.resize(BDN,1);
			}
		}
		env.end();
		t_crt=clock();
		if (t_crt-t_start>=uptime*1000){
			cout<<"Time limit reached"<<endl;
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			if (lel>-1){
				if (lwbd<lowerbound[lel][ind]-0.001){
					lwbd=lowerbound[lel][ind];
				}}
			break;
		}
	}
	if (lwbd<upperbound-0.01){
		int nbcn=bccn[ctrbdlv][crtbdnd]; 
		for (int nn=0; nn<crtusedbcn;++nn){
			nbcn+=1;
			int thecut=usedbcset[nn]; 
			bccset[ctrbdlv][crtbdnd].resize(nbcn,thecut); 
		}
		bccn[ctrbdlv][crtbdnd]=nbcn;
		int thetype=-1; 
		int then1=-1;
		int then2=-1;
		double minscore=0.49;
		double tempd=0;
		if (mintsol==0){
			for (int kk=0;kk!=K;++kk){
				if (berused[kk]>=2){
					for (int nn=0;nn!=berused[kk];++nn){
						int tempber=usedbt[kk][nn];
						double trv=KBresult[kk][tempber];
						if (trv>=0.5){
							tempd=trv-0.5;}
						else {
							tempd=0.5-trv;}
						if (minscore>tempd){ 
							minscore=tempd;
							thetype=1;
							then1=kk;
							then2=tempber;
						}
						if (minscore<0.001){
							break;
						}
					}
				}
				if (minscore<0.001){
					break;
				}
			}
			if (thetype==-1){ 
				for (int kk=0;kk!=K;++kk){
					if (nt1used[kk]>=2){
						for (int nn=0;nn!=nt1used[kk];++nn){
							int tempt1=usedt1[kk][nn];
							double trv=T1result[kk][tempt1];
							if (trv>=0.5){
								tempd=trv-0.5;}
							else {
								tempd=0.5-trv;}
							if (minscore>tempd){ 
								minscore=tempd;
								thetype=2;
								then1=kk;
								then2=tempt1;
							}
							if (minscore<0.001){
								break;
							}
						}
					}
					if (minscore<0.001){
						break;
					}
				}
			}
			if (thetype==-1){
				for (int kk=0;kk!=K;++kk){
					if (nt3used[kk]>=2){
						for (int nn=0;nn!=nt3used[kk];++nn){
							int tempt3=usedt3[kk][nn];
							double trv=T3result[kk][tempt3];
							if (trv>=0.5){
								tempd=trv-0.5;}
							else {
								tempd=0.5-trv;}
							if (minscore>tempd){ 
								minscore=tempd;
								thetype=2;
								then1=kk+K;
								then2=tempt3;
							}
							if (minscore<0.001){
								break;
							}
						}
					}
					if (minscore<0.001){
						break;
					}
				}
			}
		}
		if (Pintsol==0){ 
			Pintsol=1;
			if (thetype==-1){
				double ISresult[I][S]; 
				int shiftused[I];
				vector<vector<int>> usedshift(I);  
				for (int k=0;k!=I;++k){
					shiftused[k]=0;
				}
				for (int i=0;i!=I;++i){
					for (int s=0;s!=S;++s){
						ISresult[i][s]=0;
					}
				}
				for (int nn=0; nn!=pnumused;nn++){
					double trv=pusedcolval[nn];	
					int h=pusedcol[nn]; 
					int theshift=pcolshift[h]; 
					int thelen=pcollen[h];
					for (int nn=0;nn!=thelen;++nn){
						int theind=pcoltasks[h][nn]; 
						if (theind!=-1){
							int thect=Iset[theind]; 
							if (ISresult[thect][theshift]==0){
								shiftused[thect]+=1;
								usedshift[thect].resize(shiftused[thect],theshift);
							}
							ISresult[thect][theshift]+=trv;
						}
					}
				}
				for (int kk=0;kk!=I;++kk){
					if (shiftused[kk]>=2){
						Pintsol=0;
						for (int nn=0;nn!=shiftused[kk];++nn){
							int temp=usedshift[kk][nn]; 
							double trv=ISresult[kk][temp];
							if (trv>=0.5){
								tempd=trv-0.5;}
							else {
								tempd=0.5-trv;}
							if (minscore>tempd){ 
								minscore=tempd;
								thetype=3; 
								then1=kk;
								then2=temp;
							}
							if (minscore<0.001){
								break;
							}
						}
					}
					if (minscore<0.001){
						break;
					}
				}
			}
			if (thetype==-1){ 
				double IIresult[I+2][I+2]; 	
				int followers[I];
				vector<vector<int>> usedflw(I); 
				for (int i=0;i!=I+2;++i){
					for (int j=0;j!=I+2;++j){
						IIresult[i][j]=0;
					}
				}
				for (int k=0;k!=I;++k){
					followers[k]=0;
				}
				for (int nn = 0; nn !=pnumused; nn++) {
					double trv=pusedcolval[nn];	
					int h=pusedcol[nn]; 
					int thelen=pcollen[h]; 
					int thelt=I+1; 
					for (int nn=0;nn!=thelen;++nn){
						int theind=pcoltasks[h][nn]; 
						int thect;
						if (theind!=-1){
							thect=Iset[theind];} 
						else{
							thect=I; 
						}
						if (thelt<I){
							if (IIresult[thelt][thect]==0){
								followers[thelt]+=1;
								usedflw[thelt].resize(followers[thelt],thect);
								if (followers[thelt]>1.01){
									Pintsol=0;
								}
							}
							IIresult[thelt][thect]+=trv;
						}
						thelt=thect;
					}
					if (thelt<I){
						if (IIresult[thelt][I+1]==0){
							followers[thelt]+=1;
							usedflw[thelt].resize(followers[thelt],I+1);
						}
						IIresult[thelt][I+1]+=trv;
					}
				}
				for (int kk=0;kk!=I;++kk){
					if (followers[kk]>=2){
						for (int nn=0;nn!=followers[kk];++nn){
							int temp=usedflw[kk][nn];
							double trv=IIresult[kk][temp];
							if (trv>=0.5){
								tempd=trv-0.5;}
							else {
								tempd=0.5-trv;}
							if (minscore>tempd){ 
								minscore=tempd;
								thetype=4; 
								then1=kk; 
								then2=temp; 
							}
							if (minscore<0.001){
								break;
							}
						}
					}
					if (minscore<0.001){
						break;
					}
				}
			}
		}
		if (mintsol!=1 || Pintsol!=1){ 
			double mobj=lwbd-lwpsc;
			double theintsol=Primal(mintsol, Pintsol,mobj);
			if (theintsol>lwbd+0.0001){
				int crtlel=lel+1;
				if (crtlel+1>levels){
					levels+=1;
					nodenum.resize(levels,0);   
					nodeindx.resize(levels);
					lowerbound.resize(levels);
					brcho[0].resize(levels);
					brcho[1].resize(levels);
					brtype.resize(levels);
					brnd1.resize(levels);
					brnd2.resize(levels);
					bendcutnode[0].resize(levels);
					bendcutnode[1].resize(levels);
					fxn.resize(levels);
					fxves.resize(levels);
					fxberth.resize(levels);
				}
				nodenum[crtlel]+=1;
				int lenum=nodenum[crtlel];
				nodeindx[crtlel].resize(lenum);
				nodeindx[crtlel][lenum-1].resize(1,ind); 
				nodeindx[crtlel][lenum-1].resize(2,branch);
				lowerbound[crtlel].resize(lenum,lwbd);
				brcho[0][crtlel].resize(lenum,1);
				brcho[1][crtlel].resize(lenum,1);
				brtype[crtlel].resize(lenum,thetype);
				brnd1[crtlel].resize(lenum,then1);
				brnd2[crtlel].resize(lenum,then2);
				bendcutnode[0][crtlel].resize(lenum,ctrbdlv);
				bendcutnode[1][crtlel].resize(lenum,crtbdnd);
				fxn[crtlel].resize(lenum,crtfn);
				fxves[crtlel].resize(lenum);
				fxberth[crtlel].resize(lenum);
				for (int mm=0;mm!=crtfn;++mm){
					int theves=crtfv[mm];
					int theberth=crtfb[mm];
					fxves[crtlel][lenum-1].resize(mm+1,theves);
					fxberth[crtlel][lenum-1].resize(mm+1,theberth);
				}
			}
		}
		if (mintsol==1 && Pintsol==1){ 
			if (lwbd-lwpsc+uppsc<upperbound){
				upperbound=lwbd-lwpsc+uppsc;
				cout<<"a new upper bound is found by branching"<<upperbound<<endl;}
		}
	}
	return lwbd;
}

void nodebranch(){ 
	int fnode;              
	int flayer;              
	double sepe=0.01;
	while(1){
		totallb=upperbound;
		int tnn=0;
		vector<int> opennd; 
		vector<int> openlv;  
		for (int ll=0;ll!=levels;++ll){
			int tndn=nodenum[ll];
			for (int nn=0;nn!=tndn;++nn){
				double thelb=lowerbound[ll][nn];
				if (thelb<upperbound-0.001){
					if (brcho[0][ll][nn]==0 && brcho[1][ll][nn]==0){
						lowerbound[ll][nn]=LL;
					}
					else {
						tnn+=1;
						openlv.resize(tnn,ll);
						opennd.resize(tnn,nn);
						if (thelb<totallb){
							totallb=thelb;
						}
					}	
				}
			}
		}
		totalgap=100*(upperbound-totallb)/totallb;
		cout << "the optimality gap is:"<<totalgap<<"%"<<endl;
		t_crt=clock();
		if (totalgap<=totalerr){
			cout<<"optimality gap reached"<<endl;
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			break;
		}
		if (t_crt-t_start>=uptime*1000){
			cout<<"Time limit reached"<<endl;
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			break;
		}
		if (tnn==0){
			cout<<"all nodes have been closed"<<endl;
			t_crt=clock();
			cout<<"time="<<(t_crt-t_start)/1000<<endl;
			break;
		}
		double thelb=LL-10;
		if (tnn>0){ 
			flayer=-10;
			fnode=-10;  
			for (int mm=0;mm!=tnn;++mm){
				int templv=openlv[mm];
				int tempnd=opennd[mm];
				if (brcho[0][templv][tempnd]==1 || brcho[1][templv][tempnd]==1){
					double templb=lowerbound[templv][tempnd];
					if (thelb>templb){
						thelb=templb;
						flayer=templv;
						fnode=tempnd;
					}
				}
				if (thelb==totallb){
					break;
				}
			}
			if (fnode!=-10){ 
				if (brcho[0][flayer][fnode]==1){
					brcho[0][flayer][fnode]=0;
					cout<<"0-branch on node["<<flayer<<"]["<<fnode<<"]"<<endl;
					mastersolver (flayer,fnode,0,sepe); 
					}
				if (brcho[1][flayer][fnode]==1){
					brcho[1][flayer][fnode]=0;
					cout<<"1-branch on node["<<flayer<<"]["<<fnode<<"]"<<endl;
					mastersolver (flayer,fnode,1,sepe); 
					}
			}
		}
	}
	cout << endl;
	cout << endl;
	cout << "the final optimality gap is:"<<totalgap<<"%"<<endl;
	cout << endl;
}

void solvebap(){
	inputData();
	mastersolver(-1,-1,-1,0.01);
	nodebranch();
}

void reswrite(){
	cout <<"CPU time:"<<double(t_end-t_start)/double(1000)<<endl;
	cout <<"Upper bound:"<<upperbound<<endl;
	cout <<"Gap:"<<totalgap<<endl;
}

int main (int argc, char **argv) {
	t_start=clock();
	cout << "formulation" << endl;
	solvebap();
	t_end =clock();
	reswrite();
	cout << "succeeded" << endl;
	return 0;
}
